## 방법1. 스택 자료구조 사용하기
(성공) 154932 kb   1436 ms

```python
from collections import deque

n = int(input())
arr = list(map(int, input().split()))

answer = [-1] * n
s = deque() # 스택
s.append(arr[n-1])

for i in range(n-2, -1, -1):
    # s가 비거나 s[-1]가 arr[i] 보다 큰 값이 될 때까지 s에서 pop 하기
    while s and s[-1] <= arr[i]:
        s.pop()
    # s 에 값이 남아있다면
    if s:
        answer[i] = s[-1] # answer[i]에 정답 저장하기 (s가 비었다면 answer[i]는 -1)
    # s에 arr[i] 넣어 다음 번에도 s 사용해 오큰수 구할 수 있도록 하기
    s.append(arr[i])

for a in answer:
    print(a, end=' ')
```

## 방법2. 투 포인터 사용하기
(성공)  30864 kb  108 ms

```python
n = int(input())
columns = [
    tuple(map(int, input().split()))
    for _ in range(n)
]
columns.sort()

# 가장 높은 기둥 중 가장 왼쪽에 있는 것의 인덱스 찾기
highest_i = 0
for i in range(1, n):
     _, h = columns[i]
     if h > columns[highest_i][1]:
         highest_i = i

answer = columns[highest_i][1] # 가장 높은 기둥 하나 만큼 정답에 더하기

# highest_i의 왼쪽에 있는 기둥들을 왼쪽에서부터 확인하며 정답에 더하기
s, e = 0, 0   # s번째 기둥이 e번째 기둥보다 왼쪽에 있어야 함.
# s 가 highest_i 보다 작은 동안만 반복
while s < highest_i:
    # e번째 기둥의 높이가 s번째 기둥의 높이보다 크게 될 때까지 e 증가시키기
    while e+1 <= highest_i and columns[e][1] <= columns[s][1]:
        e += 1
    # 정답에 s번째 기둥의 높이를 높이로 가지고
    # (e번째 기둥의 위치 - s번째 기둥의 위치)를 밑변으로 가지는 직사각형의 넓이를 더해준다.
    answer += (columns[e][0] - columns[s][0]) * columns[s][1]
    s = e # s 를 e로 바꾸어 넓이를 중복해서 더하지 않도록 한다.

# highest_i의 오른쪽에 있는 기둥들을 오른쪽에서부터 확인하며 정답에 더하기
s, e = n - 1, n - 1 # s번째 기둥이 e번째 기둥보다 오른쪽에 있어야 함.
while s > highest_i:
    # s번째 기둥의 높이가 highest_i번째 기둥의 높이와 동일한 경우, e == highest_i 이 될 것.
    while e-1 >= highest_i and columns[e][1] <= columns[s][1]:
        e -= 1
    answer += (columns[s][0] - columns[e][0]) * columns[s][1]

    s = e

print(answer)
```
