### 동전 더하기
>서로 다른 동전 n 종류로 금액 k를 완성시키기 위해 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하세요.    
>단, 2번째부터 주어지는 동전의 가치값은 항상 바로 전 동전의 가치의 배수로 주어집니다.     
>**입력 형식**    
>첫 번째 줄에 동전의 종류 개수 n과 금액 k가 공백을 사이에 두고 주어집니다.    
>두 번째 줄부터 n개의 줄에 걸쳐 각 동전의 가치가 작은 동전부터 큰 동전까지 순서대로 주어집니다.  
>* 1 ≤ n ≤ 10
>* 1 ≤ k ≤ 100,000,000
>* 1 ≤ 동전의 가치 ≤ 1,000,000
>* 단, 주어진 동전들로 k원을 만들지 못하는 입력은 주어지지 않습니다.
>
>**출력 형식**    
>첫 번째 줄에 k원을 만드는데 필요한 동전의 개수의 최솟값을 출력합니다.

**풀이** : 동전이 배수로 주어지므로 그리디 알고리즘으로 풀 수 있다. 단위가 큰 동전부터 우선적으로 사용해가면 사용하는 동전의 최소 개수를 구할 수 있다.

```python
n, k = tuple(map(int, input().split()))
coins = [
    int(input())
    for _ in range(n)
]

answer = 0  # 정답 (필요한 동전 개수) 저장할 변수
i = n-1   # coins 리스트를 마지막 원소부터 확인하기 위한 인덱스
# 단위가 큰 동전을 우선적으로 사용하면 정답을 구할 수 있다! (그리디 알고리즘)

# k 가 0이 되면 반복문 탈출
while k > 0: 
    ith_cnt = k // coins[i]  # i번째 동전을 쓸 수 있는 최대 개수 구하고
    answer += ith_cnt       # answer에 더해주고
    k -= (coins[i] * ith_cnt)  # 그만큼 금액을 빼주고
    i -= 1    # 다음으로 더 작은 단위의 동전을 화인하기 위해 i 값 감소시키기

print(answer)
```

### 연속 부분 합의 최댓값 구하기 2
>n개의 정수가 입력으로 주어지고, 이 중 연속한 부분 수열에 속한 원소들의 합이 최대가 될 때의 값을 출력하는 코드를 작성해보세요. (단, 부분 수열은 최소 한 개 이상의 원소를 포함합니다.)    
>**입력 형식**    
>첫 번째 줄에는 원소의 개수 n이 주어지고, 두 번째 줄에는 n개의 정수가 공백을 사이에 두고 주어집니다.    
>* 정수는 -1,000 ~ 1,000 사이의 범위를 갖습니다.
>* 1 ≤ n ≤ 100,000
>
>**출력 형식**
>연속한 부분 수열의 원소들의 합이 최대가 될 때의 값을 출력합니다.

**풀이** : 순서대로 숫자들을 보며 구간을 확장시키다가, 합이 음수가 되는 순간 구간 확장을 멈추고 그 다음 원소부터 다시 구간을 만들어나가는 그리디 알고리즘을 사용해 해결할 수 있다.

```python
import sys
INT_MAX = sys.maxsize

n = int(input())
numbers = list(map(int, input().split()))

curr_sum = 0
max_sum = -INT_MAX

# 수열의 숫자들을 차례대로 확인하며
for number in numbers:
    curr_sum += number  # curr_sum에 더한 후
    max_sum = max(max_sum, curr_sum) # max_sum을 갱신한다.
    # 만약 curr_sum이 음수가 되었다면 더 진행하는 의미가 없으므로 0으로 초기화한다.
    if curr_sum < 0: 
        curr_sum = 0

print(max_sum)
```

### 쪼개어 배낭 채우기 구현
>도둑이 보석방을 털러 갔습니다. 보석방에는 n개의 보석이 있고, 도둑 가방의 크기는 m이기 때문에 이보다 더 많은 양의 무게에 해당하는 보석들을 담아 나올 수는 없습니다. 또한, 보석은 종류별로 단 하나씩만 있으며 각 보석을 원하는 만큼 쪼개어 담는 것이 가능합니다.    
>예를 들어 도둑방에 보석이 다음과 같이 5개가 있는 경우를 살펴봅시다. 이때 도둑 가방의 크기는 8이라 가정합니다.    
>
>| 보석 번호 | 무게 | 가격 |
>| --- | --- | --- |
>| 1 | 2 | 3 |
>| 2 | 6 | 5 |
>| 3 | 2 | 4 |
>| 4 | 3 | 2 |
>| 5 | 4 | 3 |
>
>이 예시에서는 1번 보석과 3번 보석을 담고, 2번 보석의 2/3 만큼 담으면 무게는 정확히 8이 되며 이때 가치는 10.333이 됩니다. 이 예시에서 이보다 더 크게 가치를 만들 수는 없습니다.    
>도둑 가방 크기의 정보와 보석의 정보가 주어졌을 때, 얻을 수 있는 최대 가치를 구하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫째 줄에는 N과 M이 공백을 사이에 두고 주어집니다.    
>두 번째 줄 부터는 N개의 줄에 걸쳐 보석의 정보 (w, v) 가 공백을 사이에 두고 주어집니다. w는 해당 보석의 무게를 의미하며, v는 해당 보석의 가치를 의미합니다. (1 ≤ w ≤ 1,000, 1 ≤ v ≤ 1,000)    
>* 1 ≤ N ≤ 100,000
>* 1 ≤ M ≤ 1,000,000,000
>
>**출력 형식**     
>얻을 수 있는 최대 가치를 소숫점 셋째자리까지 반올림하여 출력합니다.

**풀이** : (가치, 무게, 가격) 튜플을 jewels에 저장한 후 내림차순으로 정렬한다. 그리고 jewels 리스트의 원소들을 차례대로 살펴보며 가치가 높은 물건을 우선적으로 가방에 넣도록 한다.

```python
n, m = tuple(map(int, input().split()))
inputs = [
    tuple(map(int, input().split()))
    for _ in range(n)
]
jewels = [] # (가치, 무게, 가격) 튜플 저장
for w, p in inputs:
    jewels.append((p/w, w, p))

jewels.sort(reverse=True) # 내림차순으로 저장 (가치 높은 순)

answer = 0

for r, w, p in jewels:
    # 만약 가방에 넣을 수 있는 무게(남은 무게)가 현재 보석의 무게 이상이라면
    if m >= w:   # 현재 보석을 전부 가방에 담는다.
        answer += p    # 따라서 answer에 p를 더하고
        m -= w         # 가방 무게에서 w를 뺀다.
    # 만약 가방에 넣을 수 있는 무게보다 현재 보석의 무게가 더 무겁다면
    else:  # 필요한 만큼 담고 반복문을 탈출한다.
        answer += r * m   # 가치 * 남은 무게 만큼을 answer에 더해주고
        break             # 반복문에서 탈출해


print(f"{answer:.3f}")  # 소숫점 셋째자리까지 반올림한 답을 출력한다.
```

### 숫자 합치기
>n개의 숫자가 주어졌을 때, 2개의 숫자를 골라 하나의 숫자로 합치는 과정을 단 하나의 숫자가 남을 때까지 반복하려고 합니다. 이때 2개의 숫자가 a, b였다면, 이 두 숫자를 합치는 데 드는 비용은 a + b 입니다. n개의 숫자를 잘 합쳐 하나의 숫자가 되기까지의 가능한 최소 비용을 구하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에는 n이 주어집니다.    
>두 번째 줄에는 n개의 숫자가 공백을 사이에 두고 주어집니다.    
>* 1 ≤ n ≤ 100,000
>* 1 ≤ 주어지는 숫자 ≤ 10,000
>
>**출력 형식**    
>n개의 숫자를 합쳐 하나의 숫자로 만드는 데 필요한 최소 비용을 출력합니다.

**풀이** : while문을 사용해 리스트에 남는 원소가 하나가 될 때까지 최솟값 두 개를 pop해 그 합을 answer에 더한 후 도로 push하기를 반복한다. 이 때 
계속 변하는 리스트에서의 최솟값을 빠르게 알아내기 위해 heapq 모듈을 활용하였다.

```python
import heapq   
# 매번 최솟값 두 개를 pop해서 그 합을 다시 push해주어야 하므로 heapq 사용 

n = int(input())
pq = list(map(int, input().split()))

heapq.heapify(pq) # heapq (min heap) 으로 만들기
answer = 0   # 답 저장할 변수

while len(pq) > 1:  # 남는 원소가 하나가 되면 반복문 탈출
    a = heapq.heappop(pq) # 최솟값 두 개를 pop
    b = heapq.heappop(pq)
    answer += (a + b)     # 두 수의 합을 answer에 더함 (비용)
    heapq.heappush(pq, a+b)  # 두 수의 합을 도로 heapq에 push

print(answer)  # 정답 출력
```

### 회의실 준비 구현
>하나의 회의실이 있고, n개의 회의 요청이 들어왔습니다. 각 회의의 시작 시간과 끝 시간이 주어져 있으며, 한 회의가 시작되면 도중에 그만둘 수 없고, 한 회의가 끝나는 직후에 동시에 다른 회의가 시작될 수 있습니다. 적절하게 회의 요청을 수락하여 최대로 많은 회의가 진행되도록 하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에 회의 요청이 들어온 횟수 n이 주어집니다.    
>두 번째 줄부터는 n개의 줄에 걸쳐 회의의 정보 (s, e)가 한 줄에 하나씩 공백을 사이에 두고 주어집니다. 이 는 해당 회의가 시간 s에서 시작하여 시간 e에 끝남을 의미합니다. 여기서 시간은 편의상 하나의 정수값으로 주어집니다. 
>* 1 ≤ n ≤ 100,000
>* 0 ≤ 주어지는 시간 ≤ 100,000
>
>**출력 형식**    
>첫 번째 줄에 최대로 진행할 수 있는 회의 수를 출력합니다.

**풀이** : 강의가 일찍 끝나는 순서대로 선택해본다.

```python
n = int(input())
meetings = [
    tuple(map(int, input().split()))
    for _ in range(n)
]

# key 매개변수를 가지는 sort() 함수는 key 값을 기준으로 정렬되고 기본값은 오름차순입니다. 또한 lambda식을 사용할 수 있습니다.
meetings.sort(key=lambda x: x[1]) # 강의 끝나는 시간을 기준으로 sort

answer = 0 # 정답 저장할 변수
prev_e = 0 # 이전에 택한 강의가 끝난 시간 저장할 변수

# meetings 리스트를 빨리 끝나는 순서대로 확인하며
for s, e in meetings:
    # 이번 강의가 바로 이전에 택한 강의와 겹치지 않는다면 선택
    if s >= prev_e:  
        answer += 1  # 정답 증가시키고
        prev_e = e   # prev_e를 현재 강의가 끝나는 시간으로 갱신

print(answer) # 정답 출력
```

### 최대 숫자 만들기
>n개의 숫자가 주어졌을 때, 적당한 순서에 맞춰 나열하여 각 숫자들을 붙여 만들 수 있는 숫자 중 가능한 최댓값을 출력하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에 n이 주어집니다.    
>두 번째 줄부터 n+1 번째 줄 까지 n개의 숫자가 차례대로 주어집니다. 
>* 1 ≤ n ≤ 50,000
>* 1 ≤ 주어지는 숫자들의 범위 ≤ 10^9
>
>**출력 형식**    
>n개의 숫자를 적당한 순서에 맞춰 나열하여 각 숫자들을 붙였을 때 나올 수 있는 숫자 중 가장 큰 값을 출력합니다.

**풀이** : functools의 cmp_to_key() 를 사용해 두 숫자를 이어붙일 때 더 큰 순서대로 정렬되도록 한다. cmp_to_key()에 전달할 함수 compare() 에서 원하는 순서라면 -1을, 
반대라면 1을, 우선순위가 같다면 0을 반환한다.

```python
# functools.cmp_to_key(func) 함수는 sorted와 같은 정렬 함수의 key 매개변수에 
# 함수(func)를 전달할 때 사용하는 함수이다.
# 단, func 함수는 두 개의 인수를 받아들이고, 첫번째 인수를 기준으로 그들을 비교하여, 
# 작으면 음수, 같으면 0, 크면 양수를 반환하는 비교 함수이어야 한다.
from functools import cmp_to_key

n = int(input())
arr = [
    int(input())
    for _ in range(n)
]

# 원하는 순서라면 0보다 작은 값을, 반대라면 0보다 큰 값을,
# 우선순위가 동일하다면 0 반환
def compare(x, y):
    xy = int(str(x) + str(y))
    yx = int(str(y) + str(x))
    # xy 순서가 yx 순서보다 더 크다면 우리가 원하는 순서이므로 -1 반환
    if xy > yx:
        return -1
    # yx 순서가 xy 순서보다 더 크다면 우리가 원한느 순서가 아니므로 1 반환
    elif yx > xy:
        return 1
    # 두 수의 우선순위가 같다면 0 반환
    else:
        return 0

arr.sort(key=cmp_to_key(compare)) # compare() 함수 기준으로 정렬시키기

# 정렬한 순서대로 숫자 합쳐서 출력하기
for elem in arr:
    print(elem, end="")
```

### 수 채우기
>주어진 금액을 2원과 5원 동전을 이용해서만 만들려고 합니다.    
>사용하는 동전의 총 개수를 최소로 하려고 할 때, 2원 동전과 5원 동전은 총 몇 개가 필요한지를 구하는 프로그램을 작성하세요.    
>**입력 형식**    
>첫 번째 줄에는 금액 n이 주어집니다.
>* 1 ≤ n ≤ 100,000
>
>**출력 형식**    
>필요한 최소 동전의 개수를 출력합니다.    
>만약 2원 동전과 5원 동전으로 만들 수 없다면 -1을 출력합니다.

**풀이** : 5원 동전을 1개, 2개, ..., n//5개 사용하는 경우에 대해 각각 원하는 금액을 만들 수 있는지 확인하고 가능한 경우 정답을 최솟값으로 갱신해준다.

```python
import sys
INT_MAX = sys.maxsize

n = int(input())

answer = INT_MAX

# i는 사용하는 5원 동전의 개수를 의미한다.
for i in range(1, n // 5 + 1): 
    # 만약 i개의 5원 동전을 사용할 경우 원하는 금액을 만들 수 없다면
    if (n - 5 * i) % 2 != 0:
        continue      # continue
    # 만약 만들 수 있다면 정답 갱신
    answer = min(answer, i + ((n - 5 * i) // 2))


if answer == INT_MAX:
    print(-1)
else:
    print(answer)
```

### 자동차 단일 거래 이익 최대화하기 2
>향후 n년 간의 자동차 가격 정보가 미리 주어졌을 때, 자동차를 단 한 번 사서 되팔 때의 이익을 최대화하고자 합니다. 낼 수 있는 최대 이익을 출력하는 프로그램을 작성해보세요. 단, 자동차를 사기 전에는 팔 수 없습니다.    
>**입력 형식**    
>첫 번째 줄에는 n이 주어지고, 두 번째 줄에는 n년 간 각 해의 자동차 가격이 공백을 사이에 두고 주어집니다.   
>* 자동차 가격은 00 ~ 2^31 −1 사이의 범위를 갖습니다.
>* 1 ≤ n ≤ 100,000
>
>**출력 형식**    
>자동차를 단 한 번 사서 되팔 때의 최대 이익을 출력합니다. 단, 이익이 나지 않는 경우 0을 출력해줍니다.

**풀이** : 자동차를 산 가격은 첫 번째 원소로 먼저 저장해두고 두 번째 원소부터 자동차를 팔 가격을 for문을 통해 가져와 수익을 확인하고 답을 갱신한다. 만약 수익이 음수라면 자동차를 산 가격을 현재 파는 가격으로 바꾸어준다.

```python
n = int(input())
arr = list(map(int, input().split()))

answer = 0 # 정답 저장할 변수 (최댓값으로 갱신)
buy = arr[0] # 자동차를 산 가격 저장할 변수, 첫 번째 원소부터

# 두 번째 원소부터 자동차를 팔 가격 확인
for i in range(1, n):
    sell = arr[i]
    # arr[i]를 파는 가격으로 했을 때의 수익이 현재 answer보다 크다면 갱신
    answer = max(answer, sell - buy) 
    # 만약 arr[i]에 팔았을 때의 수익이 음수라면 buy를 현재 sell로 바꿔주기
    if sell - buy < 0:
        buy = sell

print(answer)
```

### 높은 숫자의 카드가 이기는 게임
>A와 B가 카드게임을 하고 있습니다. 1부터 2N까지 번호가 쓰인 카드가 한 장씩 총 2N장 있으며, A와 B가 카드를 N개씩 나눠 가집니다. A와 B는 한 번에 카드 한 장씩을 내고, 더 큰 숫자의 카드를 가진 사람이 점수를 1점 얻습니다. 카드는 한 턴에 한 번 까지만 낼 수 있고, A와 B는 모든 카드를 다 낼 때 까지 이를 N번 반복합니다. B가 카드를 내는 순서가 주어졌을 때, A가 얻을 수 있는 점수의 최댓값을 구하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에 N이 주어집니다.    
>두 번째 줄부터 N개의 줄에 걸쳐 한 줄에 하나씩 B가 내는 카드들이 순서대로 주어집니다.
>* 1 ≤ N ≤ 50,000
>
>**출력 형식**    
>첫 번째 줄에 A가 얻을 수 있는 점수의 최댓값을 출력합니다.

**풀이** : 2n개의 원소를 가지는 리스트 B를 정의하고 B[i]에는 B가 i+1번 카드를 내면 1, 내지 않으면 0을 저장한다. 그리고 for문을 통해 이 리스트를 순회하면서 B가 가진 카드이면 
b_played를 증가시키고 A가 가진 카드이면 b_played에 있는 이 카드로 이길수 있는 B가 가진 카드의 수를 참고해 b_played가 0보다 크다면 answer를 증가시키고 b_played를 감소시킨다.

```python
n = int(input())
B = [0 for _ in range(2 * n)] 
# B가 i+1번째 카드를 낸다면 1, 내지 않는다면 0
for _ in range(n):
    num = int(input())
    B[num-1] = 1

answer = 0 # 정답 저장할 변수
b_played = 0 # 현재 시점에서 B가 보다 작은 숫자를 가진 카드를 몇 개나 낸 상태인지 저장

# 카드 개수만큼 for문으로 순회하면서
for i in range(2 * n):
    # 만약 B가 이 카드를 낸다면 b_played를 증가시키고
    if B[i] == 1:
        b_played += 1
    # 만약 A가 이 카드를 내면서 
    else: 
        # b_played 가 양수라면 (A가 이 카드를 냄으로써 이기는 판이 있다면)
        if b_played > 0: 
            answer += 1 # answer를 증가시키고
            b_played -= 1 # b_played를 감소시킨다

print(answer)
```

### 폭탄 해체 작업
>N개의 시한 폭탄이 있습니다. 각 폭탄을 해체하는데는 1 시간이 걸리며, 폭탄마다 해체하면 얻을 수 있는 점수가 있습니다. 각 폭탄마다 해체해야만 하는 시간 제한이 정해져 있으며, 시간이 다 되어 터진 폭탄은 이후 해체할 수는 없게 되지만 다른 폭탄 해체 작업에 영향을 주지는 않습니다. 폭탄 해체 작업은 모든 폭탄이 해체되거나 터질 때 까지 진행합니다. 폭탄을 해체해서 얻을 수 있는 점수의 최댓값을 구하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에는 N이 주어집니다.    
>두 번째 줄 부터 N개의 줄에 걸쳐 각 줄에 각 폭탄을 해체해서 얻을 수 있는 점수와 시간 제한이 공백을 사이에 두고 차례대로 주어집니다.    
>* 1 ≤ N ≤ 10,000
>* 1 ≤ 폭탄 당 점수 ≤ 1000
>* 1 ≤ 폭탄 당 시간 제한 ≤ 10,000
>
>**출력 형식**    
>첫 번째 줄에 폭탄을 해체해서 얻을 수 있는 점수의 최댓값을 출력합니다.

**풀이** : 각 폭탄을 해체할 시간을 정하기 위해 사용할 리스트 times의 원소들을 0으로 초기화해둔다. times[i]에는 i 시간에 해체해야 하는 폭탄이 있으면 1, 없으면 0이 저장될 것이다. 
bombs 리스트를 먼저 점수가 높은 순으로 정렬한 뒤 for문으로 순회하는데, 최대한 제한 시간에 가까운 시간에 그 폭탄이 해체되도록 하여 최대한 많은 폭탄이 해체될 수 있도록 한다.

```python
n = int(input())
bombs = [
    tuple(map(int, input().split()))
    for _ in range(n)
]
times = [0 for _ in range(10001)] 
# times[i] 에는 i번째로 해체한 폭탄이 있으면 1, 없으면 0이 저장될 것이다

bombs.sort(key = lambda x: -x[0]) # 점수가 높은 순으로 정렬
answer = 0

# 각 폭탄을 확인하며 해체 가능하면 answer에 점수 더하기
for s, t in bombs:
    # 제한 시간에 최대한 가까운 시간에 폭탄 해체하기 위해 for문으로 
    # times[t]부터 times[1]까지 살펴보다가 0이면
    # (= 그 시간에 해체해야 하는 폭탄이 없다면)
    # 그 값을 1로 바꾸어주고 answer에 s를 더해주고 살펴보기를 멈춘다.
    # 만약 times[1]까지 살펴보았는데도 0이 없었다면 해체할 수 없는 폭탄이다.
    idx = t
    for i in range(idx, 0, -1):
        if times[i] == 0:
            times[i] = 1
            answer += s
            break

print(answer)
```

### 회의실 겹치지 않게 하기
>하나의 회의실이 있고, n개의 회의 요청이 들어왔습니다. 각 회의의 시작 시간과 끝 시간이 주어져 있으며, 한 회의가 시작되면 도중에 그만둘 수 없고, 한 회의가 끝나는 직후에 동시에 다른 회의가 시작될 수 있습니다. 이때 회의실은 하나밖에 없기 때문에 취소하는 회의 개수를 최소화하여 원활하게 진행할 수 있는 회의의 수를 최대로 하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에 회의 요청이 들어온 횟수 n이 주어집니다.    
>두 번째 줄부터는 n개의 줄에 걸쳐 회의의 정보 (s, e)가 한 줄에 하나씩 공백을 사이에 두고 주어집니다. 이 의미는 해당 회의가 시간 s에서 시작하여 시간 e에 끝남을 의미합니다. 여기서 시간은 편의상 하나의 정수값으로 주어집니다. 
>* 1 ≤ n ≤ 100,000
>* 0 ≤ 주어지는 시간 ≤ 100,000
>
>**출력 형식**    
>첫 번째 줄에 최대한 많은 수의 회의가 원활하게 진행되기 위해 취소해야 하는 최소 회의 수를 출력합니다.

**풀이** : 회의실 준비 구현 문제와 같은 방식으로 풀되, answer를 n으로 초기화해두었다가 회의를 하나씩 선택할 때마다 감소시켜주어 남는 회의의 개수를 구할 수 있도록 한다.

```python
n = int(input())
meetings = [
    tuple(map(int, input().split()))
    for _ in range(n)
]

# key 매개변수를 가지는 sort() 함수는 key 값을 기준으로 정렬되고 기본값은 오름차순입니다. 또한 lambda식을 사용할 수 있습니다.
meetings.sort(key=lambda x: x[1]) # 강의 끝나는 시간을 기준으로 sort

answer = n # 정답 저장할 변수
prev_e = 0 # 이전에 택한 강의가 끝난 시간 저장할 변수

# meetings 리스트를 빨리 끝나는 순서대로 확인하며
for s, e in meetings:
    # 이번 강의가 바로 이전에 택한 강의와 겹치지 않는다면 선택
    if s >= prev_e:  
        answer -= 1  # 정답 감소시키고
        prev_e = e   # prev_e를 현재 강의가 끝나는 시간으로 갱신

print(answer) # 정답 출력
```
