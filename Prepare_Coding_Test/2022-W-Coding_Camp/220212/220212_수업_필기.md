# 02.08

### 질의응답

sortedcontainers 는 코테에서 사용 불가. (TreeMap, TreeSet) → 이런 자료구조를 써야만 풀리는 문제는 코딩테스트에 안나온다. Priority Queue, 이진탐색 등으로 해결 가능.

### 우선순위 큐

PriorotyQueue는 느려서 heapq를 이용하는 것이 좋다. heapq는 기본적으로 min heap. class를 만들어서 최대값을 뽑아주는 max heap처럼 사용 가능.

heappush, heappop 모두 O(logN)

min heap을 max heap으로 사용하려면 push할 때 - 붙이고 pop 할때 - 붙이면 됨

- 설명
    
    ```python
    import heapqpq = [] # min-heapheapq.heappush(pq, 3) #O(logN)
    
    heapq.heappush(pq, 5)print(pq[0]) # 최솟값 3heapq.heappop(pq) # O(logN)
    
    print(pq[0]) # 최솟값 5if pq: # 비어있지 않다면    
        print("비어있지 않아요")
    
    if not pq: # 비어있다면
        print("비어있어요")
    ```
    
- 최대 숫자 구하기
    
    ```python
    import heapq
    # 변수 선언 및 입력:
    n, m = tuple(map(int, input().split()))
    arr = list(map(int, input().split()))
    pq = []
    # priority queue에
    # 숫자들을 넣어줍니다.
    # 최댓값을 구해야 하므로
    # -를 붙여서 넣어줍니다.
    for elem in arr:
        heapq.heappush(pq, -elem)
    # m번에 걸쳐서 
    # 최댓값을 찾아 1씩 빼주는 것을 반복합니다.
    for _ in range(m):    # 최댓값을 찾고 제거합니다.
        max_val = -heapq.heappop(pq)    # 1 뺀 값을 다시 넣어줍니다.
        # -를 붙여서 넣어줘야 함에 유의합니다.
        heapq.heappush(pq, -(max_val - 1))
    
    print(-heapq.heappop(pq))
    ```
    
- 최소 숫자 구하기
    
    ```python
    import heapq
    # 변수 선언 및 입력:
    n = int(input())
    arr = [
        int(input())
        for _ in range(n)]
    pq = []# priority queue를 이용하여 진행합니다.
    for elem in arr:
        # 0이 아니라면,
        # 해당 숫자를 priority queue에 넣어줍니다.
        if elem != 0:
            heapq.heappush(pq, elem)
        # 0이라면
        # 가장 작은 값을 출력하고
        # 배열에서 제거합니다.
        else:
            # 배열이 비어있다면 0을 출력합니다.
            if not pq:
                print(0)
            # 그렇지 않다면 최솟값을 제거합니다.
            else:
                print(heapq.heappop(pq))
    ```
    
- 가장 가까운 점
    
    ```python
    import heapq
    # 변수 선언 및 입력:
    n, m = tuple(map(int, input().split()))
    points = [
        tuple(map(int, input().split()))
        for _ in range(n)]
    pq = []
    # priority queue에
    # x + y, x, y 순으로
    # 우선순위가 되도록 합니다.
    for x, y in points:
        heapq.heappush(pq, (x + y, x, y))
    # m번에 걸쳐 
    # 가장 가까운 점을 잡아
    # 2씩 더해주는 작업을 합니다.
    for _ in range(m):
        _, x, y = heapq.heappop(pq)
        # 그 다음 위치를 추가합니다.
        x, y = x + 2, y + 2
        heapq.heappush(pq, (x + y, x, y))
    
    _, last_x, last_y = heapq.heappop(pq)
    print(last_x, last_y)
    ```
    

### Prefix Sum

- 정수 n개의 합 2
    
    ```python
    import sys
    INT_MIN = -sys.maxsize
    # 변수 선언 및 입력:
    n, k = tuple(map(int, input().split()))
    arr = [0] + list(map(int, input().split()))
    prefix_sum = [0] * (n + 1)
    ans = INT_MIN
    # [s, e] 구간 내의 원소의 합을 반환합니다.
    def get_sum(s, e):
    return prefix_sum[e] - prefix_sum[s - 1]
    # 누적합 배열을 만들어줍니다.
    prefix_sum[0] = 0
    for i in range(1, n + 1):
    prefix_sum[i] = prefix_sum[i - 1] + arr[i]
    # 모든 구간에 대해 합을 찾아
    # 그 중 최댓값을 갱신합니다.
    for i in range(1, n - k + 2):
    ans = max(ans, get_sum(i, i + k - 1))
    print(ans)
    ```
    
- 정수 n개의 합 3
    
    
    |  | 0 | j - 1 | j |
    | --- | --- | --- | --- |
    | 0 |  |  |  |
    | i - 1 |  | S_i-1_j-1 | S_i-1_j |
    | i |  | S_i_j-1 | (A_i_j) |
    
    → `S_i_j` = `S_i-1_j` + `S_i_j-1` - `S_i-1_j-1` + `A_i_j`
    
    |  | 0 | y1-1 | y1 | y2 |
    | --- | --- | --- | --- | --- |
    | 0 |  |  |  |  |
    | x1-1 |  | S_x1-1_y1-1 |  | S_x1-1_y2 |
    | x1 |  |  |  |  |
    | x2 |  | S_x2_y2-1 |  | S_x2_y2 |
    
    → (x1, y1) ~ (x2, y2) 합 = `S_x2_y2` - `S_x1-1_y2` - `S_x2_y1-1` + `S_x1-1_y1-1`
    

### Grid Compression

### LR Technique
