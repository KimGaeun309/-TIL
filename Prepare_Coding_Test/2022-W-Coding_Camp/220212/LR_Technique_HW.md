## 마라톤 중간에 택시타기
>마라톤 코스는 N개의 체크포인트로 구성되어 있으며, 1번 체크포인트에서 시작해서 모든 체크 포인트를 순서대로 방문한 후 N번 체크포인트에서 마라톤이 끝납니다. 게으른 개발자 A는 막상 대회에 참가하려 하니 귀찮아져서 중간에 있는 체크포인트 한 개를 몰래 건너뛰려 합니다. 단, 1번 체크포인트와 N번 체크포인트를 건너뛰면 티가 많이 나기 때문에 이 두 체크포인트는 건너뛰지 않으려고 합니다. 개발자 A가 체크포인트 한 개를 건너 뛰어서 마라톤을 완주하려고 할 때, 최소 거리를 구하는 프로그램을 작성해보세요. 단, 거리 계산은 택시 거리(Manhattan Distance)를 이용합니다. 택시거리란 (x_1, y_1)과 (x_2, y_2) 지점 간의 거리를 |x_1 - x_2| + |y_1 - y_2| 로 계산하는 것을 의미합니다. 또한, 체크 포인트의 좌표는 겹쳐져 주어질 수도 있으며, 이 경우 개발자 A가 체크포인트를 건너뛸 때 그 번호의 체크포인트만 건너뛰게 되며 그 점에 있는 모든 체크포인트를 건너뛰지 않음에 유의합니다.     
>**입력 형식**    
>첫 번째 줄에 체크포인트 N이 주어집니다.    
>이후 N개의 줄에 걸쳐 한 줄에 하나씩 각 번호에 해당하는 지점의 위치 (x, y)가 공백을 사이에 두고 주어집니다.    
>* 3 ≤ N ≤ 100,000
>* -1,000 ≤ x, y ≤ 1,000
>
>**출력 형식**    
>첫 번째 줄에 마라톤을 완주하는 최소 거리를 출력합니다.

**출력** : L 배열에 L_i = 1번부터 i번까지 인접한 숫자간의 쌍의 합을 전부 구해 두고, R 배열에 R_i = i번 부터 N번까지 인접한 숫자간의 쌍의 합을 구해 두면 
중간에 한 구간을 건너뛸 때의 거리를 구하기 쉽다. 

```python
import sys
INT_MAX = sys.maxsize

n = int(input())
check_points = [0] * (n+1) # check_points[1] 는 1번 체크포인트

for i in range(1, n+1):
    check_points[i] = tuple(map(int, input().split()))

# 두 지점간의 거리를 구하는 함수
def distance(p1, p2):
    x_1, y_1 = p1
    x_2, y_2 = p2
    return abs(x_1 - x_2) + abs(y_1 - y_2)

L = [0] * (n+1)
R = [0] * (n+1)

# L 배열 채우기
for i in range(2, n+1):
    L[i] = L[i-1] + distance(check_points[i-1], check_points[i])

# R 배열 채우기
for i in range(n-1, 0, -1):
    R[i] = R[i+1] + distance(check_points[i+1], check_points[i])

min_dist = INT_MAX

# 2번 ~ n-1번 체크포인트를 건너뛰는 경우의 거리를 모두 구해보며 그 중 최솟값을 찾기
for i in range(2, n): # i는 건너뛸 포인트 번호
    tmp = L[i-1] + R[i+1] + distance(check_points[i-1], check_points[i+1])
    min_dist = min(min_dist, tmp)

print(min_dist) # 답 출력
```

## 미래가 보이는 가위바위보
>A와 B가 가위바위보를 총 N회 진행합니다. A는 B가 무엇을 낼지 알고 있습니다. A는 주먹, 가위, 보자기 중 같은 것을 연속해서 내고, 게임 N회 중 최대 한 번만 자신이 내는 것을 바꿔, 이후에는 바꾼 것을 계속 내려고 합니다. 예를 들어 K번 연속 주먹을 내고, N-K번은 가위를 냅니다. A가 이길 수 있는 게임 수의 최댓값을 구하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에 N이 주어집니다.    
>두 번째 줄부터 N개의 줄에 걸쳐 각 줄에 주먹, 가위, 보자기 중 B가 무엇을 내는지에 대한 정보가 주어집니다. H는 주먹, S는 가위, P는 보자기를 나타냅니다.    
>* 1 ≤ N ≤ 100,000
>
>**출력 형식**    
>첫 번째 줄에 A가 이길 수 있는 게임 수의 최댓값을 출력합니다.

**풀이** : H_L, H_R 은 주먹을 냈을 때 이기는 횟수를, P_L, P_R 은 보자기를 냈을 때 이기는 횟수를, S_L, S_R 은 가위를 냈을 때 이기는 횟수를 세기 위한 리스트들이다. 
이 리스트들을 채우고 max_win(k) 이라는 k+1번째부터 다른 것을 내는 경우의 최대 횟수를 구하는 함수를 만들어 for문으로 k = 0 ~ k < n 까지 확인하며 최대 승리 횟수를 센다.

```python
n = int(input())
arr = [input() for _ in range(n)]
H_L, H_R = [0]*n, [0]*n
P_L, P_R = [0]*n, [0]*n
S_L, S_R = [0]*n, [0]*n

# L 리스트들 채우기
for i in range(n):
    if arr[i] == 'S':
        H_L[i] += 1
    elif arr[i] == 'H':
        P_L[i] += 1
    else:
        S_L[i] += 1
    if i > 0:
        H_L[i] += H_L[i-1]
        P_L[i] += P_L[i-1]
        S_L[i] += S_L[i-1]

# R 리스트들 채우기
for i in range(n-1, -1, -1):
    if arr[i] == 'S':
        H_R[i] += 1
    elif arr[i] == 'H':
        P_R[i] += 1
    else:
        S_R[i] += 1
    if i < n-1:
        H_R[i] += H_R[i+1]
        P_R[i] += P_R[i+1]
        S_R[i] += S_R[i+1]

# 인덱스 k까지 내던 것과 다른 것을 k+1부터 내는 경우의 최대 승리 횟수 계산하는 함수
def max_win(k):
    if k == n-1:
        return max(H_L[n-1], P_L[n-1], S_L[n-1])
    return max(H_L[k] + P_R[k+1], H_L[k] + S_R[k+1],\
               P_L[k] + H_R[k+1], P_L[k] + S_R[k+1],\
               S_L[k] + H_R[k+1], S_L[k] + P_R[k+1])

answer = 0

for i in range(n):
    win = max_win(i)  # k = 1 ~ k < n 까지의 최대 승리 횟수 확인해 
    answer = max(answer, win) # 정답 갱신

print(answer) # 답 출력
```

## 인접하지 않은 3개의 숫자
>n개의 숫자가 주어졌을 때, 서로 인접하지 않도록 3개의 숫자를 적절하게 골라 합이 최대가 되도록 하는 프로그램을 작성해보세요.    
>**입력 형식**    
>첫 번째 줄에는 n이 주어집니다.    
>두 번째 줄에는 n개의 숫자가 공백을 사이에 두고 주어집니다.    
>* 5 ≤ n ≤ 100,000
>* 1 ≤ 주어지는 숫자 ≤ 100,000
>
>**출력 형식**    
>첫 번째 줄에 인접하지 않은 세 숫자의 합 중 최댓값을 출력합니다.

**풀이** : L에는 L[i]에 L[0]부터 L[i]까지 중 최댓값이 저장되도록 하고 R에는 R[i]에 R[n-1]부터 R[i]까지 중 최댓값이 저장되도록 한 후 답 구하기

```python
n = int(input())
arr = list(map(int, input().split()))

L, R = [0]*n, [0]*n

# L 배열 채우기 (왼쪽부터 최댓값)
L[0] = arr[0]
for i in range(1, n):
    L[i] = max(L[i-1], arr[i])
    
# R 배열 갱신 (오른쪽부터 최댓값)
R[n-1] = arr[n-1]
for i in range(n-2, -1, -1):
    R[i] = max(R[i+1], arr[i])

max_sum = 0

# 인접하지 않는 세 수의 합 중 최댓값 찾기
for i in range(2, n-2):
    max_sum = max(max_sum, L[i-2] + arr[i] + R[i+2])

print(max_sum) # 답 출력
```

## 구간 외 최대 숫자
>n개의 숫자가 주어졌을 때, q개의 질의에 대해 주어진 구간 밖에 있는 숫자들 중 최댓값을 출력하는 프로그램을 작성해보세요.    
>단, 구간은 n개의 숫자의 번호에 해당하는 숫자로 주어집니다.    
>**입력 형식**    
>첫 번째 줄에는 n과 q가 공백을 사이에 두고 주어집니다.    
>두 번째 줄에는 n개의 숫자가 공백을 사이에 두고 주어집니다.    
>세 번째 줄 부터는 q개의 줄에 걸쳐 구간에 대한 정보 a_i, b_i 값이 공백을 사이에 두고 주어집니다. 이는 주어진 n개의 숫자들을 1번부터 n번까지 순서대로 번호를 붙였을 때 번호가 [a_i, b_i] 사이에 있지 않은 숫자들 중 최댓값을 구해야 함을 의미합니다.  
>* 1 ≤ n, q ≤ 100,000
>* 1 ≤ 주어진 숫자 범위 ≤ 10^9
>* 1 < a_i ≤ b_i < n
>
>**출력 형식**    
>q개의 질의에 대해 각 구간 밖에 있는 숫자들 중 최댓값을 한 줄에 하나씩 출력합니다.

**풀이** : 인접하지 않는 3개의 숫자 문제와 비슷한 방법으로 해결

```python
n, q = tuple(map(int, input().split()))
arr = list(map(int, input().split()))
queries = [
    tuple(map(int, input().split()))
    for _ in range(q)
]

L = [0] * n
R = [0] * n

# L 배열 채우기 (L[i] = L[0]~L[i] 중 최대값)
L[0] = arr[0]
for i in range(1, n):
    L[i] = max(L[i-1], arr[i])

# R 배열 채우기 (R[i] = R[n-1]~R[i] 중 최대값)
R[n-1] = arr[n-1]
for i in range(n-2, -1, -1):
    R[i] = max(R[i+1], arr[i])

# 질의 받으며 답 구해 출력
for s, e in queries:
    print(max(L[s-2], R[e]))
```
