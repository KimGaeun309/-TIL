# 1주차 강의

## 1-Intro to SP (2022)

### 실강

- 시스템 프로그래밍은 어떤 과목일까
    
    OS의 기능을 잘 알고 응용 프로그램에서 잘 활용한 소프트웨어와 그러지 못한 소프트웨어는 성능에서 큰 차이가 난다. 예를 들어 buffer를 활용하고 안하고의 차이는 수십 배 이상. 따라서 좋은 소프트웨어를 만들기 위해 OS의 기능을 잘 이해할 필요가 있다. 
    
    리눅스 가입? 해서 리눅스 기본 명령어들을 사용해보고 vi 라는 텍스트 에디터를 이용해 소스 코드 편집, gcc라는 C 컴파일러와 gdb라는 디버거 사용해볼 것. 연습!
    
    Operating System은 하드웨어를 효과적으로 사용할 수 있도록 하는 소프트웨어. 대표적으로 윈도우, 맥OS, 리눅스, IOS, 안드로이드 등이 있다. 전자 기기들에는 OS가 들어있다. OS는 멀티 유저 시스템으로, 여러 사용자들이 동시에 사용할 수 있도록 되어있다. 또 프로세스(실행 중인 프로그램) 하고 스케줄링(여러 프로세스를 차례대로 동작시킴) 하고 User space와 Kernel space가 구분된다. Kernel은 다른 사용자들이 손상시키지 못하도록 보호하는 공간이다. IO 장치도 보호받는 공간이다. 
    
- 유닉스와 리눅스
    
    유닉스가 리눅스의 할아버지 격인데, C 언어는 유닉스를 만들기 위해 개발된 언어이다. 하드웨어를 직접 다루기 위해 개발되었기에 C언어에는 포인터의 개념이 도입되었다. 포인터 개념은 프로그래밍 언어 측면에서는 위험하지만 하드웨어를 다루는 입장에서는 유익하다. 유닉스는 Bell Lab에서 만들어져 유지되다가 Berkeley에서 독자적으로 개발해 Bell Lab의 System V 버전과 BSD에서 만든 버전, 두 버전이 있다. 포직스에서 두 버전과 리눅스를 포함해 시스템 기능들을 통합하는 작업을 하고 있다. 
    
    유닉스는 설계 철학이 가능하면 작게 만드는 것이다. 유닉스에는 작은 프로그램들이 많다. 이들을 하나로 통합해 큰 프로그램을 쉽게 만들 수 있는 환경이 제공된다. 그리고 단순하게 만든다. (프로그램을 만들 때 가급적이면 본연의 목적을 이루기 위해 간단하고 단순하게 만드는 것이 더 좋다.) 이들을 잘 모아 하나의 프로토타입을 빠르게 만들 수 있고 프로토타입니 완성되면 프로젝트를 위한 디자인을 새롭게 시작할 수 있다. 이를 위해 효율성보다는 portability - 이식성 - 을 더 중요시해 많은 기기들의 os를 빠르게 탑재하고 이식하도록 한다. 소프트웨어에서 하드웨어에 의존하는 부분은 최소화하고 나머지는 high level 언어로 만들 수 있도록. 하드웨어 관련된 부분은 조금만 고치고 바로 사용할 수 있도록. 그리고 직접 administrator가 어떤 utility를 사용하지 않고 바로 편집기를 열어서 편집할 수 있도록 한다. 유닉스는 가급적이면 binary로 configuration을 만들지 않고 텍스트 파일로 보관한다. 쉘 스크립트를 사용한다. 쉘(명령어 실행 창)에서 명령어를 사용할 수 있도록 하는 기법 - 스크립트. 그리고 사용자의 입력을 개입하는 어플케이션들은 그 자체로의 목적에는 부합하나 다른 프로그램과 연동하기 어렵다. 그 프로그램에서 나온 정보를 다른 곳에 넣어주기 위해 필요한 captive interface를 제거하기 위해 노력했다. 따라서 정보를 처리해서 처리된 결과를 넘겨주도록 설계되어있다. 
    
    13page - 단일 명령어 여러 개를 엮어서 사용할 수 있다.여러 개의 명령어를 엮어서 하나의 프로토콜을 만들 수 있다. 
    
    유닉스 계열의 여러 OS가 내려오는 족보. MINIX를 뜯어고쳐 만든 것이 LINUX 0.1이다.
    
    GNU 개념 : GNU는 free software poundation이라는 그룹과 연관이 있다. 지적 재산을 보다 창의적인 쪽으로 공유하는 운동을 하고 그에 대한 대가는 다른 방식으로 지불하는 체제. GNU’s Not Unix → GNU 라이센스를 만들었다. Linux는 모두 GNU 라이센스를 사용해 공유하고 제약 조건들을 따르도록 되어 있다.
    
    Linux는 POSIX(UNIX의 통합 운동?)를 따른다. GNU 라이센스를 사용해 리눅스 커널 소스를 공개하기 때문에 어떤 어플리케이션을 만들었는데 그 어플리케이션이 리눅스 소스를 수정했다면 그것을 공개하도록 되어 있다. preemitible kernel은 매우 어려운 커널 (real-time system?) 리눅스 스탠다드 베이스라는 그룹에서 여러 버전들 중 기본적으로 포함해야 하는 것들을 제정하고 관리하고 있다.
    
    open source이고 소스 코드에 대한 royalty가 없지만 그 안에서 사용된 기술들에 대한 royalty는 있다. 하지만 자유롭게 쓸 수 있어 교육용으로 또는 서버 쪽에서 많이 사용되고 있다.
    
    [http://www.kernel.org](http://www.kernel.org) 는 커널 업그레이드될 때마다 공개하는 곳.
    
    [http://lxr.free-electrons.com/](http://lxr.free-electrons.com/) 은 ...
    
- 컴퓨터 시스템과 리눅스 구조
    
    하드웨어와 어플리케이션을 중개하는 소프트웨어가 operationg system. system call은 일종의 서비스 계층으로 파일 오픈, 파일 리드 등을 할 때 이를 이용한다. system call의 기능이 매우 중요하며 우리는 이번 학기에 system call에 대해 공부할 것이다. 
    
    OS 에서 메모리를 ..하는 핵심 파트를 Kernel이라고 한다. 쉘, 컴파일러, 시스템 라이브러리 등을 OS의 한 부분으로 볼 수 있고 System S/W라고 할 수 있다. 그리고 장치들과도 Kernel이 인터페이스하는데 이 사이에 device driver라는 소프트웨어가 있다. 밑에 있는 하드웨어들을 제어하는 역할을 device driver가 하므로 OS에서는 device driver에 명령을 내린다. 따라서 device driver를 OS가 만들라고 하는 규격대로 만들어야 한다. (open, read, write, close, ioctl 등의 기능을 제대로 수행할 수 있도록)
    
    system call은 리눅스 시스템에 접근하기 위해 OS 가 제공하는 function이다. 
    
    printf, scanf 등은 library routines에 있다. printf 소스를 보면 어떤 인자가 들어왔는지 체크하고 마지막으로 system call을 불러 OS의 도움을 받는다.  system call은 write라는 기능의 system call을 부른다. 그러면 OS에 이 요청이 간다. 
    
    kernel의 가장 중요한 기능은 process management이다.
    
- 시스템콜
    
    리눅스를 쓰면 시스템 콜에 대한 정보를 바로 확인할 수 있다. man 이라는 명령어를 사용해서 (manual) 시스템에 들어가서 로그인을 했는데 거기에서 어떤 기능에 대해 궁금하면 `man 궁금한 키워드` 를 쳐서 확인 가능. 리눅스에 제공하는 매뉴얼이 여러 개가 있다. 프로그램, 쉘 명령어 등... 2번 섹션은 시스템 콜, 3번 섹션은 라이브러리 콜, 4번은 스페셜 파일, 5번은 파일 포맷, ..등등 여러 섹션이 있는데 같은 명령어가 두 곳 이상에서 정의되는 경우가 있다. 이때 섹션을 지정해주면 좋다. `man 3 printf` 처럼. 23page의 그림이 매우 중요하다. 
    
    24page - fgetc, fscanf 등 c 라이브러리 함수를 쓰면 read()라는 시스템 콜을 부른다. 이때 trap이라는 것은 일종의 interrupt이다. (예를 들어 유선 전화를 사용하는데 전화기의 벨이 고장났는데 중요한 연락이 오게 되어 있다면 계속 전화기를 들어볼 것. 만약 어떤 사건을 interrupt 방식으로 알려주지 않는다면 cpu가 계속 사건이 일어나는지 않는지 확인해야 함. 하지만 인터럽트(벨) 가 일어난다면 잠시 하던 일을 멈추고 그에 해당하는 인터럽트를 처리하고 다시 하던 일을 할 수 있도록 하는 인터럽트라는 매커니즘을 지원한다.) 
    
    26page가 우리가 이번학기에 배울 시스템 콜들이다. 우리는 이것들을 적용해 실습을 해볼 것이다. 프로세스 관련, 파일 관련, IPC, Signal, 메모리 매지지먼트, 동기화, 타임 매니지먼트, 네트워크 소켓 관련.. 50개 가량의 system call들 익히자.
    

### 녹강

- Logging in

    
    XShell 설치하고 지정된 서버에 아이디로 접속해서 password 바꾸고 간단한 커맨드들 연습하기
    
- Shell?

    
    쉘이란 커널을 감싸고 있는 계층으로 사용자가 명령을 내릴 수 있도록 명령을 처리하는 계층. 다른 프로그램을 실행시키거나 파일을 관리하고 만들어진 프로세스를 종료하거나 중단시킬 수 있다. 
    
    리눅스 서버에 로그인하면 쉘 프로그램이 제일 먼저 동작하고 우리는 쉘 인터페이스에서 쉘 커맨드를 내릴 수 있다.
    
- Commomly Used Shells
    
    
    여러 개의 쉘들이 있는데 쉘도 프로그램이라는 것을 기억할 것. 커널에 종속되어 있지만 쉘도 독립적인 프로그램.
    
    사용자의 입력을 받아서 명령어면 실행시키고 커널의 정보를 가져오라는 거면 가져오도록 while loop을 도는 것이 쉘 프로그램의 기본 틀이다.
    
- Shell Interactive Use
    
    
    작업을 해 나가는데 기존의 명령을 다시 쓸 수 있도록 지원하거나 기존의 명령을 편집해 사용할 수 있다.
    
    그리고 ls 치고 tab → ls로 시작하는 파일 이름 보여줌. 자동 완성 기능(?)
    
    단축키
    
    철자 자동으로 정정
    
    작업 중단
    
- Types of Arguments
    
    
    계속 실습해야 하는 과목이다. 
    
- Simple Commands
    
    
    쉘의 명령어를 입력하는 형태들을 보자. 
    
    명령어니까 기본적으로 단어로 되어 있는데 하나의 단어로 이루어진 것도 있고, 인자(arguments)가 공백으로 분리되어 주어질 수도 있다.  
    
    쉘에 argument 를 전달할 때 명령어까지도 argument 형태로 주어주는데 첫번째 인자 (numbered zero) 는 실행할 명령어 string을 담는다. 그 뒤로 따라오는 인자들은 명령어에 전달해야 할 인자들일 수 있다. 이는 파일 이름이나 경로나 디렉토리 등의 정보일 수 있다.
    
    파이프 기호나 화살표 기호와 같은 특수한 기호들이 명령어에 추가되면 그 기호들을 쉘들이 처리해서 기호에 맞는 동작을 지원하도록 할 수도 있다.
    
- Simple Example
    
    
    `ls` (명령어) : 디렉토리의 파일들 리스트를 보여주라는 명령어
    
    `-1`  (옵션) : 각 파일의 모든 정보들을 같이 출력하라는 것 (이름 뿐 아니라)
    
    `\bin` : 보고 싶은 디렉토리 명시
    
    이 명령으로 세 개의 인자가 쉘에 전달된다
    
- Types of Arguments
    
    
    `tar` (명령어) : 여러 개의 파일 또는 디렉토리를 하나의 파일로 구성하는 명령어. (압축과는 다름)
    
    `-c` : 생성해라
    
    `-v` : 과정을 보여줘라
    
    `-f` : 무조건 파일을 압축해라
    
    `archive.tar` : 목적하는 타르
    
    `main.c` , `main.h` : 파일 이름
    
    여러 개의 argument로 명령어가 구성되는 것을 볼 수 있ㅇㅁ.
    
    `-X`로 옵션을 지원하기도 하고 `--longname` 로 옵션을 지원하기도 한다.
    
    명령어마다 옵션 주는 방법이 조금씩 다르다. 
    
- Frequently Used Commands (1)
    
    
    이 곳에 보여지는 명령어들은 우리가 기본적으로 잘 익히고 사용해야 하는 명령어들이다. 리눅스 기본 명령어 첨부 파일에도 있다. 
    
    리눅스 시스템 안에 들어와서 해보는 게 중요.
    
    `vi` 는 텍스트 파일을 편집하는 편집기 프로그램. 이것을 익혀야 간단한 소스 코드를 작성하거나 보고서를 쓸 수 있다. 다음 주에 vi를 익힐 테니 예습할 수 있는 사람들은 미리 봐두자.
    
- Linux File System
    
    
    리눅스 시스템을 사용할 때 리눅스 시스템은 여러 사용자들이 사용하는 멀티 유저 시스템이므로 여러 사람들의 디렉토리를 각각 관리하고 함께 쓰는 툴이나 개발 환경, 시스템 환경들을 활용하므로 구조를 잘 알아두자.
    
    트리의 최상단(root) 에 슬래시 표시가 있다. 그 아래에 서브 디렉토리가 있고 그 아래에는 파일이나 서브 디렉토리가 또 존재한다.
    
    일반적으로 사용자마다 계정을 할당받아서 로그인해 사용하는데 mtk, avr 등이 사용자에게 주어진 계정 이름이다. (ex. mtk가 로그인하면 처음 디렉토리 위치는 /mtk 이다. ) 어떤 사용자의 기본 위치를 보통 그 사용자의 홈 디렉토리라고 한다. 
    
    루트 밑에 home 이 있는데 이것은 여러 사용자들을 관리하기 위한 디렉토리로 특정 사용자의 홈 디렉토리가 아니다. 
    
    실습할 리눅스 서버에도 여러분의 디렉토리를 만들어 뒀는데 home 아래에 sp2021 서브 디렉토리를 만들고 그 아래에 여러분 각각의 홈 디렉토리를 만들어 두었다. (ex. sp202000376)
    
- File/Directory Path
    
    
    위치를 표현할 때 경로를 표현한다 = Path를 표시한다 라고 얘기한다. 이 경로를 표현하는 방법은 두 가지가 있다.
    
    1. absolute path
        
        루트로부터 해당되는 위치까지 다 나와 있는 방식. 
        
        절대 방식.
        
    2. relative path
        
        현재 나의 위치를 중심으로 상대적인 위치로 표현하는 방식. 현재 나의 위치를 잘 알고 작업해야 한다.
        
        현재 위치는 점 하나로 표현한다.
        
        현재 위치에서 하나 위(parent)는 점 두 개로 표현한다.
        
        ‘~’ 는 어떤 유저의 home을 의미한다.
        
        `cd ~avr` 은 avr라는 유저의 홈으로 가라는 뜻이다. → 하지만 보안 상의 문제로 원칙적으로 허용되지 않는다. 이 권한을 루트, 관리자는 가지고 있다.
        
        `cd ~` 는 나의 홈으로 가라는 뜻이다. (하지만 `cd` 라고만 해도 나의 홈으로 간다)
        
- File Permission (1)
    
    
    리눅스 시스템에서는 각 파일마다 그 파일의 소유자 정보를 관리하고 있고 여러 사용자들이 동일한 권한을 가질 수 있도록 group이라는 개념을 지원하고 있다. 어떤 그룹이 sp2019 라면 sp 수업을 듣는 모든 학생들을 한 그룹으로 묶어서 그 그룹은 강의 자료의 읽기가 가능하거나 프로그램을 실행하는 것이 가능하도록 할 수 있다.
    
    따라서 파일이나 디렉토리를 생성한 소유자, 그 파일이나 디렉토리에 엑세스할 수 있는 그룹, 그리고 기타 이렇게 세 단계의 권한 설정을 할 수 있다.
    
    일반적으로 `ls-l /bin` 하면 owner와 group와 others 가 각각 어떤 권한을 가지는지를 보여준다.
    
    rwx = read write execution
    
    처음 세 개는 owner의 권한이므로 owner는 read write execute 가 모두 가능함을 알 수 있다. 그 다음으로는 group의 권한을 보여주는데 read와 execution만 가능함을 알 수 있다. 그 다음 세 개는 others이다. others도 read와 execution만 가능하다.
    
    owner는 root, group은 sys 라는 것 도 알 수 있다.
    
- File Permission (2)
    
    
    `chmod` 명령어로 권한을 바꿀 수 있다.
    
    permission 은 각각 r, w, x 세 개씩 설정할 수 있다. 1이면 허용, 0이면 허용 한하는 것이다. 
    
    111_111_100 → others가 write, execute를 못하도록 하는 것 → 8진수로 774 이므로
    
    `chmod 774 myFile.txt` 
    
    또는 아래와 같은 방법으로 권한 설정을 바꿀 수도 있다.
    
    `chmod g-r` : group에서 read 권한 빼기
    
    `chmod g+w` : group에서 write 권한 주기
    
- Linux Programming Process
    
    
    vi 또는 vim 프로그램으로 소스 코드를 편집하고 gcc(c 컴파일러) 또는 g++(c++컴파일러) 로 컴파일하고 디버깅 툴 gdb를 사용한다.
    
    디버깅을 잘 사용하면 시간을 단축할 수 있다. 
    
- gcc Compiler
    
    
    간단하게 gcc 컴파일러를 이용해 소스 코드를 컴파일할 때 어떤 일이 일어날까?
    
    gcc sample.c 라고 컴파일 명령을 내리면 a.out 이라는 이름으로 바이너리가 만들어진다. 이를 실행시킬 때 보안 상의 이유로 `./a.out` (현재 작업 디렉토리에 들어 있는 a.out) 이렇게 실행시켜야 한다.
    
    `-o`  옵션을 주면 바이너리 이름을 지정할 수 있다.
    
    두 개 이상의 파일로 이루어진 프로그램이면 파일 이름들을 나열해서 명령을 내리면 된다.
    
     `-c` 옵션을 주면 링킹은 안하고 컴파일만 하도록 한다. 그러면 —.o 파일 (오브젝트 파일) 이 만들어진다.
