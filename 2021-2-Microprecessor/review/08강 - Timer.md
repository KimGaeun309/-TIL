# 8강 - Timer

오늘 강의는 타이머에 대해서 강의를 하고 타이머를 이용한 실습 내용을 진행하겠습니다.

## 타이머와 카운터

먼저 타이머가 뭔지 타이머에 대한 개념을 설명하고 우리가 사용하는 프로세서에 실제로 들어있는 타이머가 어떻게 구현되어있는지에 대한 내용을 파악하고 타이머를 이용해 정확한 시간을 생성하는 두 가지 실습을 진행하겠습니다.

## 타이머,카운터

타이머라는 것은 컴퓨터 시스템에서 시간을 측정하는 도구이다. 컴퓨터시스템의 모든 컴퓨터 프로세서에는 cpu와 별개로 TIMER 라고 하는 컨트롤러를 갖고 있다. 타이머는 소스로부터 CLOCK신호를 받아서 clock에 대한 정확한 시간을 측정할 수 있는 제어기이다. 임베디드 시스템 분만 아니라 모든 컴퓨터 시스템은 정확한 시간을 측정하는 일이 필요하기에 타이머가 필요하다. 타이머를 이용해 할 수 있는 기능이 많다. 그 중 하나는 카운터. 그래서 타이머 혹은 카운터라고 말한다. 이 타이머,카운터를 이용해 시간 측정이 가능한데 어떻게 가능할까?

## 클럭과 카운터

### 클럭

일반적으로 프로세서는 클렉에 동기화되어 작업을 수행한다. 클럭이라고 하는 소스 clock source 가 있다. 이것은 신호를 재생해낸다. 일정 시간 간격동안 0과 1의 값이 번갈아 나타난다. 프로세서는 클럭에 동가회돠어 작업을 수행하도록 만들어졌다. 그와 더불어 우리가 클럭이 있으면 클럭은 정확하게 일정 시간이 반복되므로 하나의 클럭 신호에 해당하는 것을 주기라고 부른다. 우리는 몇 번 주기가 반복되는지를 신호를 가지고 확인할 수 있다. (신호가 반복될 때마다 counting) 따라서 주기가 얼마인지알면 counting 된 시간이 얼마인지 알 수 있다. 예를 들어 주기가 0.1초라면 8번 주기가 반복되면 0.8초가 흐른 것.

타이머라고 하는 컨트롤러에 스스로 clock signal을 넣어주면 타이머는 클럭 시그널로부터 들어오는 클럭의 횟수를 셀 수 있도록 만들어주면 클럭의 소스 시간을 기준으로 시간이 얼마나 흘렀는지를 확인할 수 있다. 또는, 시간을 정해놓고(예를 들어 100번) 그 시간이 흐르면 알려주도록 할 수 있다.

### 카운터

클럭을 세는 장치

## STM32F103 타이머,카운터

타이머는 모든 프로세서에 타이머 컨트롤러가 들어감. (인터럽트 컨트롤러, 타이머 컨트롤러는 모든 프로세서에 들어간다.) 

이 타이머를 이용해 여러가지 기능들을 구현할 수 있다. 그리고 그 타이머가 구현된 프로세서마다 특징들이 다르다. 그래서 기본 개념을 알고  각 프로세서의 특징을 이해해야 응용 가능. STM32F103 의 타이머 기능 확인하고 실습을 해보자. 그래서 우리 타이머의 기능을 살펴보자면, 4개 이상의 타이머를 보유하고 있다.(독립적인 타이머 4개) 그리고 각각의 타이머는 여러가지 동작을 사용할 수 있다. 

기본 기능으로 타이머 기능을 가지고 있는데, 타이머 기능은 타이머 컨트롤러에 인가되는 클럭 소스의 주기(frequency = 1/시간) 를 이용해 내부 클럭을 세는 장치이다. 

그리고 또 카운터 기능을 기지고 있는데, 클럭소스가 아닌 다른 외부 신호를 받아 그 신확 몇 번 발생했는지를 셀 수 있는 기능이다. 

그리고 인터럽트 기능도 가지고 있는데, 예를 들어 1초의 시간이 끝나면 타이머가 인터럽트를 발생시킬 수 있는 기능이다. cpu 내부 인터럽트 소스로서 타이머가 사용된 것. 설정한 시간이 지나면 인터럽트를 발생시켜 타이머가 cpu에게 그 시간이 지났다는 정보를 알려주는 것. 출력비교 인터럽트, 입력 갭쳐 인터럽트가 있다.

PWM 출력 기능도 가지고 있는데 이것은 타이머의 기능을 가지고 외부 출력신호를 생성해낼 수 있는 기능이다. (이 기능은 다음 시간에 확인해볼것. 이번 시간엔 타이머를 사용해 우리가 원하는 시간을 생성하는 기능에 대해 실습 두 가지를 해볼것.)

## 16비트 타이머,카운터

### 16비트 타이머,카운터의 특징

4개의 타이머가 있고 그 중 하나를 쓴다. 타이머라고 하는 것의 기능은 내부의 레지스터가 몇 개가 있다. 이론적으로는 우리가 원하는 시간만큼 클럭을 몇 번 세겠다고 설정하는 시간 설정 레지스터가 있고, 내부적으로는 클럭 소스에 대해서 클럭의 횟수를 세는 카운터 레지스터가 있다.

예를 들어 시간 설정 레지스터에 100번을 세겠다고 설정을 하고 시작하면 클럭 횟수가 지날 때마다 카운터 레지스터에서 counting 을 한다. (0부터 증가 or 100부터 감소시키는 카운팅 할 수 있다. - 업카운팅 or 다운카운팅 가능.) 우리가 원한 시간만큼 클럭의 시간이 흐르면 어떤 상태 레지스너에 시간이 다 흘렀다는 비트를 1로 설정하여 원하는 시간만큼의 시간이 흘렀다는 것을 알려준다. 이게 일반적으로 타이머가 동작하는 방식이다.

### 프리스케일러(Prescaler)

cortex-m3는 그 시간을 설정할 때 조금 복잡하게 프리스케일러를 보유하여 시간을 설정할 때 두 개의 레지스터가 존재한다. 시간설정레지스터(ARR) 와 프리스케일러(Prescaler), 둘 다 16비트이다. 이 두 개를 사용할 수 있다. 16비트로는 65535까지 카운팅할 수 있다. 클럭이 생각보다 빠르기에 이 시간은 너무 짧다. 우리가 0.1초 ~ 1초를 세려면 이보다 더 많은 시간을 셀 수 있어야 하기 때문에 prescaler 를 사용해 투 스택 카운팅을 한다. 프리스케일러가 100이면 클럭이 들어올 때 프리스케일러에서 카운팅을 하다가 100이 되면 카운팅 레지스터를 하나 증가시키고 다시 0이 된다. → 100만큼의 시간을 지연시킨다 → 65535 * 65535 시간까지 셀 수 있게 됨.

ARR 레지스터와 Prescaler 레지스터의 값을 설정해 원하는 시간을 설정하는데, clock frequency 가 주어지겠죠. 예를 들어 clock frequency가 4MHz 라면 (4 * 10^6) , 시간은 1/4*10*6 = 4 * 10^-6 = 2.5 * 10^-7 = 250ns 이다. 그리고 프리스케일러를 1024로 하면 클럭은 주기가 250ns * 1024 = 256us 이다. 이 클럭을 256 까지 센다면 256us * 256 = 65.536ms 크기의 타이머를 만들 수 있다. (ARR = 256, Prescaler = 1024 → 65.536ms 타이머) 

### 16비트 타이머,카운터의 일반 동작 모드

### 16비트 타이머,카운터의 동작

Timer Period = (Prescaler) * (ARR) / (Clock frequency)

### 16비트 타이머,카운터의 동작 예

## 16비트 타이머,카운터

### 16비트 타이머,카운터의 동작 예

우리가 사용하는 cortex-m3의 클럭은 둘 중 하나 - 36MHz or 72MHz. 

36MHz 라면 1초 카운터를 만들고 싶다면 36 * 10^-6 * Prescaler * ARR = 1초 → Prescaler에 36000,  ARR 에 1000 을 넣어주면 1초를 만들어줄 수 있다. 또는 P에 3600, ARR에 10000.

## STM32F103 인터럽트

그리고 구체적으로 타이머 동작시키기 위한 타이머의 설정이 필요한 레지스터들을 살펴보자. 자세한 내용은 매뉴얼에 설명됨. Timer 관련 내용은 몇장에 나뉘어져있지만 우리가 이번 실습에서 필요한 내용은 14장 범용 목적 타이머 내용이다. 기본적으로 타이머 기능, 카운터 기능이 있고 그 외에 부가적으로 기능들이 있다(다음 시간에 알아볼것.). 그리고 내부적으로 보면 클럭 소스에 대해 구체적으로 알 필요는 없고, PSC, CNT, Auto-reload 가 있고, 우리는 PSC, Auto-reload 레지스터를 설정시켜주어야 한다. auto-reload == cnt → 우리가 원한 시간이 흐름 → 타이머가 expired되었다 = 타이머가 만료되었다 → 끝났다는 비트. 또는 인터럽트 설정했다면 인터럽트 발생.

카운터는 내부적으로시간이 지날수록 증가시키는 레지스터, PSC, Auto-reload 는 우리가 설정해주는 레지스터. 

업카운팅, 다운카운팅 모두 가능. 레지스터에 설정하는 값에 따라.

챕터의 마지막을 보면 레지스터 맵이 있다. x는 여러가지 타이머마다 레지스터로 구성되어있는데, CR1, CR2 설정 레지스터, DIER, SR (status register), .. 등이 있다. 그리고 CNT, PSC, ARR

### 타이머 카운터 레지스터(TIMx_CR1)

제어 레지스터이다. 

타이머의 클럭 소스를 뭘로 쓸지(36MHz, 72MHz)를 CKD 가 설정한다. 기본적으론 72로 되어있고 그보다느리게 할지를 설정할 수 있다. (00: 72MHz, 01 : 36MHz, 10: 18MHz) 우리는 72MHz 쓸 것.

APRE 는 auto reload enable 인데 타이머를 한 번 쓸 때 1초를 로드한다면 1초가 끝날 때마다 ARR 을 다시 설정해야 하는데 APRE 에 1을 설정하면 ARR에 기존 설정 값을 reload 해 타이머를 재가동시킨다. 계속 타이머를 사용할거라면 필요한 설정이다.

DIR 은 디렉션, DIR = 0이면 업카운팅, DIR=1이면 다운카운팅. 

CEN 은 Count enable, 이걸 1로 설정하면 타이머가 시작한다.

### 타이머 카운터 레지스터(TIMx_CR2)

몰라도 상관X

### DMA/Interrupt Enable 레지스터(TIMx_DIER)

타이머가 expire, 만료되면 타이머 만료되었다 알려주는 레지스터의 비트가 1이 되고 그 다음으로 인터럽트가 발생시키도록 하려면 DIER 레지스터를 설정해주어야 한다. 기본 타이머 뿐만 아니라 여러가지 로드에 대한 인터럽트를 처리하는 레지스터인데 이 중 TIE 라고 하는 비트를 1로 설정하하고 UIE를 1로 설정해주면 타이머가 만료되었을때 인터럽트까지 발생시킨다. 인터럽트가 발생했을 때 ISR으로 분기해서 해당 타이머에 대한 작업을 수행할 수 있도록 벡터에 등록시킬 수 있다. 이 등록은 NVIC 컨트롤러를 통해 할 수 있다. 

### SR 레지스터(TIMx_SR)

타이머가 expire되면 TIF 에 expire가 되었다는 신호가 설정이 되도록 되어 있다. 그래서 TIF 를 보고 타이머가 expire되었음을 확인할 수 있다.

## 16비트 타이머,레지스터

### 타이머 카운터 레지스터(TIMx_CNT)

카운트 레지스터. 하드웨어가 알아서 카운팅함. 우리가 설정하지X

### 타이머 프리스케일러 레지스터(TIMx_PSC)

프리스케일러 레지스터 

우리가 설정

### 타이머 Auto-reload 레지스터(TIMx_ARR)

ARR 레지스터 

우리가 설정

## STM32F103 인터럽트

실습을 하기 위해서 아까 이론적으로 설명을 했고 그것이 실제 코드로 프로그램으로 하려면 레지스터 값을 설정해줘야 하는데 우리는 그걸 쉽게 할 수 있는 라이브러리 함수나 data structure를 사용한다. 

타이머 관련 인터럽트는 NVIC에서 보면 TIM~~이다. 

지난번 실습과 유사. 타이머 관련된 data structure와 함수 추가로 이용.

interrupt는 NVIC_InitTyteDef 에  TIM2_IRQChannel 등록시켜주고 stm32f10x_it.c 의 TIMx_IRQHandler 함수에서 처리 루틴을 구현해준다.

Timer가 expire 되었을 때 interrupt 발생시키게 해주려면 TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE) 해준다. 

이와 같이 타이머에 대한 interrupt 설정은 NVIC와 TIM 두 가지 data structure 를 통해 설정해줄 수 있다.

# 실습1 : 타이머로 led 점멸

LED 점멸시키는데 원하는 시간에 맞도록 정확한 시간에 대해 LED가 움직이도록 하는 것. 1초 타이머. 

소스 코드는 타이머의 기본 설정은 ARR , PSC 레지스터 두 개를 설정해주는데 이때 72MHz 클럭을 사용하므로 1초 = 72 * 10^-6 * PSC * ARR  이므로 PSC = 7200, ARR = 10000 설정해주면 된다. 그리고 72로 하려면 CKD(clock division)는 00으로 설정해주면 된다.

TIM_TimeBaseInitTypeDef 구조체 사용해 설정.

# 실습2 : 타이머를 이용한 디지털 시계