# 5강 - Memory

지난주까지 instruction 과 마이크로프로세서 내부에 instruction 을 기반으로 해서 소프트웨어 프로그램이 내부에서 어떻게 동작하는지에 대해 알아보았고, 이번주부터는 프로세서 바깥의 컨트롤러 를 통해 디바이스를 제어하는 마이크초 컨트롤러에 대한 이해와 실습을 해보겠습니다. 

## Agenda

기본적으로 cpu core와 여러가지 다른 디바이스들은 데이터를 주고받습니다. 죽받는데 address 를 가지고 주소를 가지고 어떤 디바이스를 적용할지 만들어낼 수 있습니다. 이를 위해 I/O address를 만들어야하는데, address 주소가 memory 에 mapping 되어 있어 그런의미로 memory mapped i/o를 사용합니다. ARM 또는 마이크로 컨트롤러에서 cpu core 가 외부 디바이스를 제어하는 방식으로 쓰이고 있습니다. cortex m3도 메모리 맵드 아이오를 사용해 외부 디바이스에 접근할 수 있는데 이 메모리 맵 주소는 cpu마다 고유한 주소를 가지도록 되어 있습니다. 비슷한 체계는 가지고 있겠지만. cortex m3도 cortex m3 만의 고유한 메모리맵을 가지고 있습니다. 그 메모리 맵에 기반해 다양한 장치들을 사용할 수 있습니다. DRAM, ROM, Code 같은 장치들 제어.

이 챕터에서는 구체적인 이 장치들에 대한 제어를 설명하는게 아니라, 전반적으로 메모리 맵은 어떻게 구성하고 있는지에 대해 설명할 것입니다.

## Roadmap

로드맵은 강의 초창기에 설명했던 것이다. cpu 가 있고, cpu는 bus를 통해 외부 장치와 통신해 주고받는다. 여러가지 다른 장치들 - gpio, timers, .... 등. 이런 장치들이 시스템 버스에 연결되어 있다. ahb,apb는 ARM 과 관련된 버스입니다.

이게 전부 하나의 칩에 ㄷ르어이쏙, core도 칩에 블락으로 되어있고, 다른 외부장치를 제어하는 컨트롤러, 제어기들도 논리화되어 칩에 들어있다. 직접 메모리도 하나의 칩 안에. 이런 여러가지 led 등과 같은 간단한 장치를 제어하는 실습을 해볼건데, 이 컨트롤러와 연결된 외부 핀들을 cpu에서 컨트롤러를 경유해 제어하도록 소프트웨어를 작성할 수 있다. 실습을 해볼때, 지금까지는 cpu가 내부적으로 돌아가는지 소프트웨어가 어떻게 돌아가는지를 assembly로 알아보았는데 지금부터는 C 코드로 외부 장치를 제어해볼 것입니다. 이런 것들을 제어하기 위한 메모리 맵에 각종 컨트롤러가 정의되어있어야 하고, 정의된 매크로나 함수들을 사용할 수 있어야 하는데 일일히 구현하기 어렵기 때문에 이런 함수들과 define이 잘 작성된 라이브러리를 적정히 활용해 작성해볼 것. 이해를 높이기 위해. 어떻게 운영되는지를 잘 이해할 수 있게 실습을 해볼 것.

## Memory-mapped I/O

일반적으로 cortex m3의 메모리가 어떻게 구성되어있나?

하나의 마이크로 컨트롤러를 제어하려면 여러가지 외부 장치들을 잘 알아야 합니다. 핸드폰에만 칩 세 개. cpu, dram, flash 메모리. flash는 sd카드 같은거, dram은 메모리. 거기에 다양한 포트, gps 등..이걸 하나의 칩으로 제어를 하는데, 아두이노, 라즈베리파이.....  이런 것도 익스텐션 핀... 여러가지 장치들을 꽂아 그 플랫폼에 소프트웨어가 돌아가도록 한다. 이 제어를 할 때 각각의 컨트롤러를 제어하기 위핸 제어 레지스터들이 있다. cpu에서 제어하는 레지스터도 있다. 레지스터에는 범용 레지스터가 있고, 컨트롤러를 제어하는 레지스터... 메모리에 맵핑되어있어 cpu가 레지스터에서 읽고 쓸 수 있게 하는데 이걸 memory mapped i/o라고 한다. 

GPIO 핀...

어떤 핀에 1을 쓰거나 0을 쓰거나 할 수 있도록 만들어놓은 컨트롤러를 GPIO 컨트롤러라고 합니다. 이를 위해 내부에 이 제어를 위한 레지스터를 만들어 놓았는데, cortex m3의 경우 0x40000000 부터가 GPIO 제어를 위한 레지스터로 맵핑을 시켜 놓았습니다. 이 레지스터 주소값에 cpu가 데이터를 쓰도록 하면 GPIO 에 어떤 값을 내보낼지 .. 만들 수 있음.

## Cortex-M3 Memory System

cortex m3는 어떻게 구성되어있을까? 32비트 머신. 0x00000000  ~ 0xFFFFFFFF.

설계를 할 때 어떤 영역ㅇ르 어떤 데에 쓸지 다 설계해두어 디바이스를 설치하든지 메모리에...하든지...

처음 0.5gb는 code 영역, 그다음 0.5gb 는 on-chip peripherals, 칩에 컨트롤러를 위한 것... 

그 다음 1Gb는 메모리.

그다음 0.5gb는 내부 컨트롤러를 위한 공간.

우리가 앞에서 사용했던 것들은 내부 SRAM 영역의 메모리에 데이터를 쓰고 읽어왔다. (0x20000000) 

그리고 실제 작성된 코드는 code 영역에서 실행이 됩니다. 

peripherals는 제일 중요.. 외부 컨트롤러들이 이 영역에 맵핑되어있습니다. 그래서 잘게 쪼개져있음. (gpio 위한 영역, int 위한 영역,timer 위한 영역... 등등)

칩 밖에 dram을 꽅았을 때도 cpu가 이 영역을 통해 접근합니다.

각 영역에 특징이 부과되어있고 각 특징마다 cpu가 접근하는 방식이 다 다릅니다. 이 방식을 네가지로 볼 수 있음.

## Memory Access Attribute

1. Bufferable : 어떤 데이터를 일시적으로 저장하는 공간을 buffer라고 함.
2. Cacheable :  cache는 재사용을 위해 데이터를 읽고 쓰기를 다른 용도로 활용하기 위해 하기 위해 일시적으로 데이터를 담을 수 있는 것.
3. Executable : 실행 가능한.  우리가 작성한 code가 code 영역에 있는데 이때 instruction을 실행해야하는데어떤 특정 명령에만 프로그램이 가동됨(??). executable하다는 건 프로그램이 존재할 수 있다는 뜻.
4. Sharable : 공유 가능한. 특정 명령이 다른 디바이스에 공유가 가능하냐.

이런 네 가지 기능을 각각의 영역에 부과할 수 있는데 그 부과된 특성에 따라 어떤 영역에는 프로그램을 넣고 어떤 영역에는 외부 디바이스를 위한 컨트롤러를 넣고를 설계할 수 있습니다.

## Cortex-M3 Predefined Memory Map

각각의 영역에 어떤 특성이 있는지를 다시 정리를 하자면,

### Code memory region (0x00000000 - 0x1FFFFFFF)

가장 하위의 0.5 GB. executable, cache attribute 실행 가능해야하고 캐시어블.

이 영역에는 ROM 같은게 붙어 파워가 나가더라도 프로그램이 사라지진 않음.

일반적으로 code는 데이터 저장 용도로 사용되지 않기 때문에 bufferable하지 않다.

### SRAM memory region (0x20000000 - 0x3FFFFFFF)

RAM 영역은 executable하다. 그리고 bufferable 하고 cache attribute 하다. 

RAM 같은 것만 붙기 때문에 파워 나가면 프로그램이 날아감.

### Periperal region (0x40000000 - 0x5FFFFFFF)

0x40000000 이 주소 기억!!

executable하지 않고, noncacheable. 외부 장치에 대한 컨트롤러 목적으로만 사용되며 code 영역과 완전히 반대된다.

### External RAM region (0x60000000 - 0x7FFFFFFF)

이 영역은 cacheable 하고 executable하다. 즉 ROM, RAM 영역은 executable하고 cacheable하다! 

그리고 periperal 영역의 경우 noncacheable, nonexecutable.

### External RAM region (0x80000000 - 0x9FFFFFFF)

이 영역은 cacheable 하고 executable하다.

### External devices (0xA0000000 - 0xBFFFFFFF)

외부 디바이스는 모두 nonexcutable.

buffer도 안됨.

### External devices (0xC0000000 - 0xDFFFFFFF)

외부 디바이스는 모두 nonexcutable.

buffer도 안됨.

### System region (0xEFFFFFFF - 0xFFFFFFFF)

nonexecutable.

## 참고자료: Default Memory Access Permissions

이 자료는 넘어가도록 하겠습니다. 내부 제어......너무 깊이 있고 잘 알아야 하는 내용이기에.

지금 꼭 알아두어야 하는 것은:

cpu가 외부장치를 사용하기 위해서는 사전에 설계된 memory map 주소 체계를 이용해 i/o를 할 수 있다. 이 내부 설계는 cpu마다 고유한 메모리에 설계되어있다. 우리가 사용하는 cortex m3는 위와 같은 체계로 이루어짐. 0.5 code, ..... 각각의 메모리 영역에 따라 특징이 다르다. 램 또는 코드 영역 → 실행가능 , 캐시나 버퍼 가능.

페리페럴 또는 디바이스,외부 제어 영역→ 실행불가능, 캐시나 버퍼 불가능.

## Ex) STM32F103 데이터 메모리 구조

우리가 실제 사용하는 cortex m3 기반으로 만들어진 상용화된 칩들 중에 STM32F103 칩이 있는데 , 이 칩의 메모리 영역은 다음과 같이 설계되어있습니다.

우리가 시뮬레이션을 하면 이 프로그램이 다운로드되어 돌아가는 영역은 0x00000000~ code 영역이 되고, 외부 장치를 제어할 때 실제 제어하는 영역은 0x40000000~ peripherals 영역이 됩니다. (led, switch 등...) 따라서 이 주소 값들을 잘 기억해두어야 합니다.

 다음 시간에 GPIO 컨트롤러에 대해 실습을 할 것입니다. GPIO (general purpose input output controller) 가 하나만 있는게 아니라, 하나의 포트는 16개 pin에 대해 개별적으로 제어 가능한데 그런 포트가 6개(A,B,C,D,E,F)가 있습니다. 이때 각 영역마다 할당되어있는 레지스터 주소 영역은 다음 표와 같습니다.

## Summary

특정 주소 영역에 디바이스들을 맵핑시켜놓고 i/o를 통해서 디바이스를 제어하는 방식을 memory mapped i/o라고 합니다.

cortex-m3에서 이 메모리 맵이 어떻게 설계되어있는지를 알아보았고, 이 영역 중에서 특히 peripheral이 외부 컨트롤러 영역이고, 이 영역을 통해 외부 장치를 제어할 수 있습니다.