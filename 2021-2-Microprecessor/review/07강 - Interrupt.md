# 7강 - Interrupt

오늘 강의는 인터럽트 컨트롤러에 대한 개념과 cortex m3의 인터럽트 컨트롤러를 이용해서 외부 신호에 대해 인터러트를 발생시키고 발생된 인터럽트에 대해 처리를 하는 방법에 대해 알아볼 것. 

## 인터럽트

### 인터럽트(Interrupt)

인터럽트의 개념을 먼저 살펴보겠습니다. "방해하다, 훼방놓다" 는 뜻. CPU 의 작업을 방해하는 일련의 신호를 인터럽트 신호라고 힌다. 일반적으로 프로그램, 코드를 cpu가 실행하는데 이 코드와 상관 없이 cpu 외부 혹은 외부에서 발생된 신호에 대해서 그 신호를 한 곳에서 담당을 하는데 이것을 Interrupt controller 라고 한다. 이 인터럽트 컨트롤러가 신호들을 받아서 어떤 신호인지 확인한다. 인터럽트 컨트롤러가 인식할 수 있는 신호의 종류가 정해져있다. 어떻게 인터럽트 신호가 발생했는지 확인하고 cpu에게 신호를 줌(→ 실질적인 인터럽트). 그러면 cpu는 프로그램을 수행하고 있다가 현재 수행중인 일을 잠시 중단하고 다른 쪽으로 분기가 일어나 급한 일을 처리하고 원래의 일을 다시 이어서 수행한다. 이 일을 처리하도록 구현된 루틴이 인터럽트 서비스 루틴이다. 인터럽트 서비스 루틴은 각 인터럽트 시그널마다 다 다르게 구현되어있다. 각 시그널마다 처리하는 일이 다 다르다.

그러면 cpu에서는 어떤 인터럽트에 대한 인터럽트 서비스 루틴으로 분기를 하는지를 관리하는 루틴이 있는데 이를 NVIC, 벡터 데이터 컨트롤러 라고 부른다. 이 영역이 서로 연관이 되어 어디에서 인터럽트 소스가 발생했는지를 알 수 있고 발생된 인터럽트 소스를 벡터 형식으로 디파인되어있는 테이블에서 어떤 인터럽트 서비스 루틴으로 분기할지를 알아낼 수가 있다.

### 인터럽트와 인터럽트 서비스 루틴

기본적으로 인터럽트라고 하는 것은 현재 cpu가 수행하는 일과 상관없이 cpu 코어 바깥에서 발생하는 신호이다. 이 신호가 발생하면 cpu는 원래 수행하던 일을 멈추고 interrupt가 발생한 source에 대한 처리를 위한 영역인 인터럽트 서비스 루틴으로 점프가 일어났다가 이 일이 끝나면 다시 복귀한다. 이것을 두고  인터럽트 발생 및 분기, 인터럽트 서비스 루틴, 복귀 의 일련의 과정을 거친다고 말한다. 

---

## 폴링과 인터럽트

### 마이크로 컨트롤러의 외부 상황 입력 방법

컴퓨터 시스템에서는 모든 cpu 바깥의 시그널들을 인터럽트로 처리하고 있다. 컴퓨터 시스템에서 키보드, 마우스, 네트워크, i/o(storage) 들(모든 cpu와 상관 없는 외부 i/o장치들)로부터 키보드 타이핑이나 마우스 움직임 등이 발생하면 인터럽트가 발생되어 해당 cpu에 전다링 되어 일단 인터럽트 서비스 루틴으로.  그래서인터럽트 방식을 주로 쓰는데 이 인터럽트 시그널을 발생시키는 주체는 신호를 인지하기 위해 cpu는 신호가 오면 신호를 발생시킨다. 따라서 외부 상황을 입력받는, 발생시키는 주체가 인터럽트 source 이고, 이 입력을 하드웨어적으로 받아 하드웨어 신호를 cpu에게 전달하도록 만드는 방식을 인터럽트 방식이라고 한다. 그러면 cpu 입장에서 외부 신호를 외부의어떤 장치들에 대한 상황인지를 하는 방식은 두 가지가 있다. 첫 번째는 외부 장치에서 알려줘서 인식하는 방식( = interrupt), 그리고 두 번째는 cpu가 자기가 외부의 장치들이 어떤 특정한 변화가 발생되었는지를 모니터링하는 방식( = polling(폴링)방식). 

이 두 방식의 차이점은 polling 방식은 예를 들어 어떤 신호가 변화되었는지를 감지하기 위해 이 신호를 계속 보고 있어야(poll을 해야)한다. 단점은 cpu의 작업 resource를 빼앗는다는 점이다. 장점은 cpu가 software적으로 보고 모니터링하기 때문에 인터럽트 컨트롤러와 같은 장치가 필요 없다. 반대로 interrupt 방식의 단점은 interrupt 처리를 위한 컨트롤러가 하드웨어적으로 필요하다는 점이다. 장점은 효율적으로 신호가 발생한 경우에만 cpu에게 전달하여 cpu는 그 상황에서만 처리하므로 성능이 좋다는 점이다.

컴퓨터 시스템에서는 다 interrupt로 처리를 한다. 그래서 인터럽트의 개념과 인터럽트가 발생한 경우 인터럽트 서비스 루틴으로 분기를 하는 일련의 과정을 알아보기 위해 강의를 보고 실습을 해보자.

---

## 인터럽트

### 인터럽트의 구성 요소

인터럽트를 처리를 하려면 먼저 인터럽트 컨트롤러가 있다. 인터럽트 컨트롤러는 NVIC,  nested vectored interrupt controller가 만들어져있다. 그리고 cpu가 있다. 또 외부 장치 또는 내부 장치에서 인터럽트가 발생해서 들어온다. 인터럽트 컨트롤러가 알아야 하는 것은 어떤 인터럽트 소스로부터 인터럽트가 발생했는지(발생원?), 발생원을 cpu에게 알려주면 cpu는 ISR, interrupt service routine 로 점프하는데, 이 루틴이 어디에 있는지를  함수들에 대한 점프 주소의 테이블인 interrupt vector table 에서 알 수 있다. 따라서 인터럽트에 대한 서비스 루틴에 대한 분기를 어디로 시켜주어야하는지를 인터럽트 벡터가 관리해준다. 그다음으로 인터럽트라는 것이 굉장히 다양한 source를 처리할 수 있다.(40~60) 그래서 어떤 경우에는 동시에 인터럽트가 발생할 수 있는데 이 경우 cpu에 신호를 전달해서 둘 다 처리해주어야하는데 이때 누구를 먼저 서비스할지(우선순위)를 관리해줄 수 있다. 

세 가지. 발생원이 누구냐. 벡터 테이블을 어떻게 관리할거냐. 중요도를 어떻게 관리할거냐.

반대로 이런 기능도 있다. interrupt mask. 어떤 인터럽트가 발생하더라도 cpu에게 넘겨주지 않는( = masking 하는)것. 특정 인터럽트에 대해 마스킹할 수도 있고, 동시에 발생했을 때 우선 순위에서 어떤 인터럽트가 발생했는지를 기록해두어야 우선순위가 높은 것을 처리한 후에 우선 순위가 낮은 것을 처리할 수 있는데 이를 pending이라 한다. 이런 기능들이 있다.

발생원을 위한 인터럽트.. 40~60개인데 하나의 비트를 할당해 어디어세 발생했는지를 인터럽트 컨트롤러에서 관리해야 하는데 그를 위한 레지스터가 있다. 그리고 masking 을 위한 레지스터도 있다. 그리고 pending을 위한 레지스터도 있다. 

그 다음에 여기엔 나오지 않는데 인터럽트라는 것을 어떻게 감지를 하냐면, 감지하는 방식은 digital에서는 신호는 0 또는 1밖에 없다. 따라서 신호의 변화를 감지해야한다. 0에서 1로 혹은 1에서 0으로 바뀌는 변화를. 0에서 1로 올라가는 것은 rising, 1에서 0으로 떨어지는 것은 falling. 그래서 이 둘 중 어떤 신호 변화가 발생하면 인터럽트가 발생했다고 할거냐를 설정할 수 있다. rising으로 인식? falling으로 인식? 둘 다 인식? 이런 기능을 설정하기 위한 레지스터도 인터럽트 컨트롤러 안에 마련되어 있다.

### 인터럽트

인터럽트는  외부 인터럽트와 내부 인터럽트가 있을 수 있는데 내부 인터럽트는 칩 안에서 특정 컨트롤러가 인터럽트를 발생시켜 인터럽트 컨트롤러에게 알려주는 것, 예를 들면 timer 등이 있다. 그리고 외부 인터럽트는 외부 핀으로부터 신호의 변화가 발생했을 경우에 인터럽트 컨트롤을 하는 것. GPIO 에 대해 지난 시간에 알아보았는데 GPIO는 input으로도 쓸 수 있고 output으로도 쓸 수 있는데 input으로 쓸 경우에 특정 기능을 부여할 수 있는데 이 특정 기능을 외부 인터럽트 시그널로 쓰겠다고 설정을 한다면 외부에서 신호가 발생하면 특정 pin에 대해 interrupt source를 쓸 수 있게 된다.

그리고 인터럽트가 발생한 경우에 인터럽트 컨트롤 차원에서 이를 cpu에게 전달할지말지를 결정할 수 있는데 (마스크, 마스킹) 정말 중요한 인터럽트 시그널들은 마스킹도 할 수 없다. 예를 들면 reset 시그널. 그래서 인터럽트를 차단가능성에 의해 분류할 수 있다. 차단(마스크) 불가능(Non maskable, NMI) 인터럽트와 차단(마스크) 가능(Maskable) 인터럽트. 일반적으로 사용하는 것들은 차단 가능하다. 그리고 인터럽트 조사 방식에 따라서도 나눌 수 있는데, 서비스 루틴으로 분기가 일어나도록 하는 조사 방식이 조사형이 있을 수 있고 벡터형이 있을 수 있다. 하지만 요즘 대부분은 벡터형 인터럽트를 사용하고 있다. H/W Interrupt Controller (Vector Table) 이 훨씬 빠르고 지연시간(latency)가 적기 때문에.

---

## STM32F103 인터럽트

인터럽트에 대한 기본 개념들을  정리해보자면, 

인터럽트는 cpu의 현재 작업을 멈추고 특정 신호를 처리하기 위해 외부로부터나 내부로부터 발생된 신호를 cpu에 전달하면 cpu가 현재 작업을 멈추고 jump해 처리하는 일련의 과정을 말한다. 우리가 실습에서 인터럽트를 확인해보아야하는데, 우리가 사용하는 칩이 인터럽트 컨트롤러가 어떻게 구성되어있고, 어떻게 우리가 인터럽트 소스를 정의를 하고 해당 소스로부터 인터럽트 시그널을 어떻게 만들어내는지, 그리고 인터럽트가 발생된 경우 어떻게 인터럽트를 처리하도록 구현을 해줄건지가 실습의 내용이 되겠다.

### STM32F103 인터럽트

그래서 우리가 사용할 칩인 cortex-m3 기반의 STM32F103 칩의 인터럽트가 어떻게 구성되어있는지를 확인해보아야겠다. 같은 cortex-m3라도 인터럽트 컨트롤러라는 것은 cpu코어와 별개로 칩 내부에 존재하는 컨트롤러 영역이다. 우리가 지난 시간엔 GPIO controller를 알아보았는데 이 또한 별개로 칩 내부에 존재하는 컨트롤러 영역이다. 

그 기능에 어떤 것이 있을까? 리셋 포함 총 43개의 인터럽트 벡터를 가지는데 이 칩이 워낙 variant가 심하기에 60개 이상의 인터럽트 소스가 있다. 이번 실습에서는 외부 인터럽트, EXTI 0, 1 확인해볼것. 아래에 적힌 것들은 내부 인터럽트. 외부 인터럽트는 GPIO를 통해 외부 신호를 받으면 신호를 발생시키는데 (EXTI 0, 1) 우리는 이에 관한 실습을 해볼거다. 

### 인터럽트 설정

### 인터럽트 설정 관련 STM32F103 레지스터

인터럽트와 관련된 핀 설정과 레지스터 설정이 필요하다. 

그 다음에 인터럽트가 발생한 경우에 외부 pin에 대해 설정해줄 때 외부 pin을 어떤 거를 설정을 할지 (GPIOA(~H) 0 ~ 16, 각 GPIO마다 핀이 16개가 있는데 이 각각의 핀들을 독립된 외부 인터럽트 소스로 쓸 수 있다.)에 대한 외부 핀 설정 레지스터(=AFIO_EXTICRn(n:1~4))가 있다.

그 다음에 이제 기본적으로는 마스킹이 안되어있어야 인터럽트 컨트롤러에게 알려주는데 이를 위한 마스크 레지스터가 있다. 기본적으로 마스크가 되어있지 않기 때문에 건드릴 필요는 없다. 그리고 마스크 레지스터 종류가 많은데 ( 인터럽트 마스크 레지스터(EXTI_IMR), 이벤트 마스크 레지스터(EXTI_EMR), 소프트웨어 인터럽트 이벤트 레지스터(EXTI_SWIER) 등... ) 이 인터럽트로 쓰이는 소스가 인터럽트인 경우, 이벤트인 경우, 소프트웨어적으로  발생한 이벤트인 경우가 있어서... 하지만 우리는 인터럽트를 발생시킨다는 점만 알아두면 된다.

그리고 인터럽트가 발생할때 rising, falling 중 어느 걸로 발생하도록 할건지를 결정하는 레지스터 ( EXTI_RTSR(rising trigger selection register), EXTI_FTSR(falling trigger selection register) ) 가 있다. 

그리고 인터럽트가 발생하면 무조건 pending 레지스터에 해당 인터럽트가 발생했음이 기록된다. 이 레지스터의 역할엔 두 가지가 있는데, 인터럽트 두 개가 동시에 발생한 경우 둘 다 이 pending register에 기록을 해서 인터럽트에 대한 처리를 놓치지 않게 하는 효과가 있고, 또 들어온 인터럽트가 연속적으로 발생하는 경우가 발생하지 않도록 한다. 결론적으로 보면 인터럽트 펜딩 레지스터는 인터럽트가 발생하면 해당 특정 핀에 인터럽트가 발생했다고 기록을 하고 이게 지워져야지 또다시 인터럽트가 발생할 수 있고 또 발생하면 다시 1이 됨.

### 인터럽트 설정

- 외부 인터럽트 제어 레지스터(AFIO_EXTICRn(n:1~4))

외부 인터럽트 핀이라 되어있는데 이건 좀 복잡한 면이 있으니까

- 외부 인터럽트 GPIO 연결

간단하게 설명하면 우리가 GPIO가 굉장히 많이 있다. A~G 0~15 까지 각각 16개씩 핀이 있으니까 총 105개 가량의 외부 핀에 대한 처리가 가능하나 현실적으로는 16개만 가능하도록 만들어놓았다. EXTI 0 ~EXTI 15 까지. 이 핀들을 어떻게..? 각 핀의 같은 자리수는 같은 인터럽트로 묶어놓음. 그래서 PA0 와 PB0 는 같은 인터럽트를 처리하므로 이 두 개는 동시에 쓸 수 없다! 그래서 결론적으로 열여섯개에서 같은 오프셋 자리에 있는 핀들은 동시에 인터럽트를 발생시킬 수 없다. 우리는 그렇게 사용하는 경우는 없기 때문에 단순하게 생각해서 GPIOA 0 ~ 15 까지 독립적으로 16개의 외부 인터럽트를 발생시킬 수 있으나 외부 인터럽트 0 (PA0) 핀과 외부 인터럽트 1 (PA1) 핀, 이 두 개의 독립적인 핀에 대해서  외부 인터럽트를 발생하도록 레지스터를 설정해줄 필요가 있다. → 이것이 NVIC에 등록이 되어있다.

### 인터럽트 마스크 레지스터(EXTI_IMR)

16개 핀.. 1로 설정하면 외부 인터럽트 발생X. 하지만 발생하도록 하려면 설정해줄 필요 X. 기본적으로 마스킹 안되어있음. 디폴트값이 0x0으로 설정되어있기 때문에.

### 이벤트 마스크 레지스터(EXTI_EMR)

### 소프트웨어 인터럽트 이벤트 레지스터(EXTO_SWIER)

### 외부 인터럽트의 트리거

여러가지 방법이 있는데 우리가 사용하는건 edge trigger.

변화에 대해? 또는 특정 레벨 값이 유지될때? edge trigger는 입력 신호가 변경되는 순간 - falling edge 또는 rising edge. level trigger는 입력 신호가 유지되는걸 봄. 유지되면 인터럽트. 또 유지되면 인터럽트.

그리고 외부 신호를 연결시켜줄 때 rising 또는 falling 정해줘야 하는데

### STM32F103 외부 인터럽트 제어 레지스터

이걸 설정하는 레지스터가 

- EXTI_RTSR, rising trigger selection register는 rising 일어날 때 인터럽트 발생. → 해당 핀에 대해 1로 설정하면 설정됨.
- EXTI_FTSR, falling trigger selection register는 falling 일어날 때 인터럽트 발생. → 해당 핀에 대해 1로 설정하면 설정됨.
- EXTI_PR, pending register 는 앞의 설정을 다 해주고 실제 인터럽트가 발생하면 1, 그리고 cpu에 알려줌. 그리고 cpu에서 처리가 끝나면 다음에 다시 인터럽트가 발생할 수 있도록 0으로 써줌. 그리고 다시 인터럽트 발생하면 1, ...

** 매뉴얼 설명 참조!! 9장 (169 ~ 181)

### STM32F103 인터럽트 프로그램

 이때까지 얘기한 이론적인 것들을 실제로 외부 인터럽트 시그널을 발생시키고 발생된 인터럽트에 대한 서비스 루틴을 어떻게 구현할 수 있는지를 알아볼 것이다. 일단 기본적으로 IAR 워크벤치에서 ...

---

# 실습

## 실습 1 : 인터럽트로 LED 점멸

## 실습 2 : 인터럽트를 이용한 스톱워치