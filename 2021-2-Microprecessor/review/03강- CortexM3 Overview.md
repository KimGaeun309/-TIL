# 3강 - CortexM3 Overview

## Fundamentals

 이 그림은 cortex-m3 코어의 내부 구조를 블럭 다이어그램 형태로 간략하게 묘사한 그림. cortex-m3 칩 안에 실제 core system이 내재되어 있다. core system 안에는 연산을 하는 ALU 로직, cpu 내의 임시저장소 역을 하는 레지스터가 있고 명령어들을 수행하기 위해 필요한 동작들(컨트롤 유닛 = Instruction fetch unit, Decoder)들이 있다. 그리고 메모리와 데이터를 주고받는 동작으 ㄹ하기 위한 Memory interface가 있다. 그리고 외부 컨트롤러 동작을 위해 외부 컨트롤러와 연결된 Bus interconnect가 있다. 여기까지가 cpu 프로세서고, 프로세서 밖에 메모리를 연결시켜줄 수 있다(Code memory, Memory system and peripherals). 그리고 메모리 이외에 다양한 i/o에 대한 제어를 하는 주변 장치에 대해 컨트롤러를 연컬시켜줄 수 있다(Private peripherals). 그리고 그 이외에 Interrupt라는 개념이 있는데, 이를 제어하기 위한 Interrupt controller(NVIC)가 있다. 그리고 학습을 할 때 디버깅을 도와줄 수 있는 Debug system이 내부에 있다. 이 기본 개념은 Cortex-M3 뿐만 아니라 대부분의 프로세서들이 이런 기본적인 블럭 형태를 가지고 있다.

우리는  우리가 작성한 s/w를 구성해서 마이크로프로세서 등의 하드웨어와 연결해 원하는 프로그램을 실행시키도록 돕는다. s/w는 우리가 소스 코드를 작성하면 바이너리 코드로 된 실행 파일이 나오는데 이 파일에 담긴 명령어들이 cpu에서 돌아간다. 이때 명령어가 동시에 돌아가는 것이 아니라 하나씩 돌아간다. 이 바이너리 파일이 Code Memory 영역에 올라가서 cpu가 이 명령어들을 한 번에 하나씩 가져와서(fetch) 명령어를 해석해(decode) 명령어를 실행하도록 cpu가 돌아간다. 명령어가 해결되면 또 그 다음 명령어를 가져와 running시킨다.  이 과정을 통해 우리가 원하는 작업을 cpu를 통해 수행시킬 수 있다.

## What Study with Cortex-M3

그래서 전반적으로 어떻게 구성이 돌아가냐면,

우리가 앞에서 본 구조를 Central Processing Unit을 한다. 우리는 Hardware 위에 Software를 돌린다. 이 Hardware에 맞는 Software는 이 Hardware가 실행할 수 있는 명령어에 맞게 Software를 작성해야 한다.. (ISA) 이 작업은 사실 컴파일러나 어셈블러가 한다. 예를 들어 우리가 C로 작성을 하면 컴파일러를 통해, Assembly로 작성을 하면 어셈블러를 통해 실행 가능한 명령어로 코드 작성(??)  우리가 어떤 명령어가 작성가능한지 간단하게 알아보고 그 명령어를 실제적으로 어떤 식으로 작성해야 실제 하드웨어(cpu)에서 돌아가는지 간단하게 알아볼 것. cpu 내부 동작의 이해를 위해 프로세서 이해를 일차적으로 할 것. 두 번재는 cpu 내부 말고 cpu와 연결되어있는 (물론 우리는 하나의 칩 안에 cpu 코어와 외부 주변 장치를 제어할 수 있는 컨트롤러들이 들어가 있고 그것들이 버스로 연결되어 있는 걸로 실습을 할 것. 그러니 실제적으로는 이 컨트롤러와 연결이 되어 있는)  GPIO/INT, Timers, USART,  Internal External Memory를 C 언어를 통해 제어하는 것을 배워볼 것. 

이 그림을 통해 우리가 배울 것들을 간략하게 요약하자면,

1. cpu 내부 동작을 이해하기 위한 ( = ISA(Instruction Set Architecture)를 통해 간단한 동작 처리를 어떻게 하는지를 이해하기 위한) 이론과 실습 (어셈블리어로)
2. 외부 제어장치로 제어하기 위해 C 프로그래밍. 라이브러리는 제공을 해줄 것. 이 라이브러리를 활용해 어떻게 제어하는지를 알아보는 실습. (Interrupts 제어, GPIO/iNT 제어, Timer 제어, USART(현재 cpu와 간단한 외부 통신 (시리얼 통신)) 제어,  DAC/ADC, 내부 & 외부 메모리.. (adress bus, data bus, control bus 를 제어하는 방식, "직접 연결을 해 제어를 하는 방식")

## Fundamentals

우리가 이제 이것을 보는 것은 하드웨어 기반 위에서 어떻게 소프트웨어를 돌릴 수 있는가를 배우려는 것. (시스템 기반의 소프트웨어를)

이번 페이지에서는 우리가 어떤어떤거를 배우는지 간단하게 살펴보자.

- Registers *
- Operation Modes
- Built-in Nested Vectored Interrupt Controller
- Memory Map *
- Bus Interface
- Instruction Set *
- Interrupt and Exception *

## Registers

대부분의 모든 cpu는 내부에 레지스터 뱅크가 있다. 이것은 cpu 내부 레지스터로 cpu 내부의 임시 저장소로 쓰인다. 이 저장소는 어떤 데이터를 연산하려 할 때 이 연산을 할 대상인 데이터를 임시로 담아두는 데 사용된다. 실질적으로 프로그램이 돌아갈 때 하드웨어에서는 메모리에 공간이 생기고, 그것을 연산하기 위해 cpu의 임시 저장공간인 레지스터로 옮겨 연산한다. 이 레지스터의 크기는 각각의 cpu마다 다른데 cortex m3에서는 R0  ~ R15 로 16개. 하나의 레지스터의 크기는 32 bit. C에서 int가 4 byte = 32 bit 이다. 그러므로 레지스터 하나가 int 하나를 담을 수 있다.

 

- R0 ~ R12 까지의 13개는 범용 목적으로 사용된다. cpu 마음대로 사용할 수 있도록 공간이다.  변수와 유사하게 소프트웨어를 작성해 실행시킬 때 cpu가 이 범용 목적의 레지스터를 활용해 연산한다. low, high 구분은 큰 의미는 없다.
- R13 ~ R15 3개는 특수 목적으로 만들어졌다.
    1. R13 은 스택을 위한 포인터(스택 포인터)로 만들어졌다. (스택  - 프로그램이 실행되다가 A라는 함수를 실행... 이 작성한 순서대로 바이너리 코드가 만들어졌을 때 이 A라는 함수를 call 하는 코드가 있을 것. call 해서 A 쪽의 코드로 이동해 프로그램이 실행되었다가 다시 이 함수를 부르기 전의 코드로 돌아가기 위해 기존의 결과를 저장해두어야 함. 이 상황에서 이전에 사용된 데이터를 백업하기 위해 활용하는 공간을 스택이라고 함. 나중에 돌아갈 위치를 지정해두기 위한 포인터 값을 저장하는 게 스택 포인터.) (스택 포인터: 스택 영역을 가리키는 주소값을 저장하는 데 사용) / 스택의 동작 방식(push, pop)이 있는데 이 동작방식은 넘어가기로 합시다.
    2. R14 는 링크 레지스터. 링크 레지스터의 용도는 나중에 설명할 것. 간단히 설명하자면, B를 실행하다 A 함수를 실행시켰을 때 A 함수 실행이 끝나고 B로 다시 돌아올 주소를 저장하고있는 레지스터이다. 즉, subroutine이 call 되었을 때 다시 돌아올 주소를 저장한다.
    3. R15 는 프로그램 카운터. 프로그램은 명령어들로 이루어져 있다. 이 프로그램을 실행시키면 소프트웨어가 메모리 위에 올라간다. 이 명령어들이 저장된 주소값이 각각 있는데, cpu는 이 주소로부터 하나씩 명령어들을 가져와 실행시킨다. 이 때 중요한 것은 어디 메모리의 주소로부터 명령어를 가져오는지. 따라서 다음에 실행될 명령어가 저장된 주소값이 중요한데 이를 프로그램 카운터라고 한다. 
- Special Registers - 현재 프로그램의 상태 (Program Status Registers, PSRs) 등...

## Operation Modes

cpu의 동작 모드.

cpu는 프로그램이 동작하는 상태를 .지정할 수 있다. 동작 상태는 크게 두 가지가 있는데, 그 중 Privilaged 상태는 특권 상태로, 시스템, os, 특정 권한을 가진 하드웨어 등이 cpu의 동작 제어권을 가지고 동작시키는 상태이고, User 모드는 일반 프로그램을, 일반 프로그램이 동작하는 상태이다.  이 정도만 알아두면 된다. 앞으로 더 알아볼 일 없음.

## Interrupt Controller

Interrupt란, 예를 들어 프로그램이 실행되는 cpu에 어떤 통신 선으로 다른 네크워크로부터 데이터가 도착하면 데이터를 받은 통신 컨트롤러가 cpu에게 받은 데이터가 있다는 신호를 보낸다. 이 때 보내진 신호를 interrupt 라고 한다. interrupt 란 일반적으로 cpu 외부에서 cpu에게 신호를 전달해 어떤 처리할 작업이 있으니 이 작업을 처리하라고 하는 것. 신호를 받은 cpu는 실행 중이던 작업을 일시적으로 멈추고 받은 작업을 마무리한 뒤 실행 중이던 작업을 마저 한다. 그런 의미에서 interrupt 라는 개념은 모든 컴퓨터 시스템에서 적용되고 있다. 통신을 통해 알게 되겠지만 컴퓨터 시스템에서 키보드를 타이핑하거나 마우스를 클릭하는 것도 interrupt가 발생하는 것이다. 예를 들어 곰플레이어 등에서 비디오를 플레이하고 있다가 스페이스 바를 누르거나 일시정지 버튼을 클릭하면 멈추라는 신호를 user로부터 받아 처리해 재생을 멈춘다. cortex m3에는 NVIC 라는 이름으로 만들어져 interrupt controller 가 cpu 내부에 하나의 칩으로 존재한다.

interrupt controller (= NVIC) 의 특징을 간단히 정리하자면, interrupt controller 는 수많은 외부 제어로부터 동시에 interrupt가 발생할 수 있기에 priority (우선순위) 를 dynamic 하게 지정해준다. 또, interrupt를 빠르게 처리해서 interrupt latency (지연 시간) 을 줄여준다. 그리고 interrupt masking 이라는 것은 interrupt가 발생할 때마다 그 신호가 cpu에 전달되는데 이 신호가 cpu에 전달되지 않도록 막는 특징이다.

## Memory Map

Cortex M3의 메모리 맵. cpu에 연결된 메모리나 많은 i/o 장치들, GPIO 장치 등이 있는데 이 장치들은 bus 에 공통적으로 물러?있다. 이 때 cpu 는 어느 장치와 데이터를 주고받는지 알기 위해 주소값을 지정한다(?) address 에 대한 map 을 만들어 어느 영역은 메모리 영역이고 어느 영역은 GPIO 영역이고를 정의해 이 정의에 맞게 하드웨어에 연결한다. cortex m3 는 이 영역을 정의해 놓았다. 주소 체계는 00000000 ~ FFFFFFFF. 

1. 60000000 ~ 9FFFFFFF 는 RAM 영역, 외부 메모리.
2. 00000000 ~ 1FFFFFFF 는 CODE 영역. 해당 코드가 ROM(read only memory)일 수도 있고 RAM(random access memory) 일 수도 있다. ROM 예시 - 플래시  메모리. 코드를 바로 실행시키고 데이터를  읽고 쓸 수 있다. RAM 예시 - DRAM. / C 등으로 코드를 짜서 실행시키면 이 영역에서 실행된다.
3. 4000000 ~ 5FFFFFFF 는 Peripherals. Peripherals 에는 모든  io 주변장치가 연결되어있다. 
4. E0000000 ~ FFFFFFFF 에는 여려 내부 컨트롤러들이 있는데, NVIC 같은 경우 여기에 담겨 있다. 

## The Bus Interface

cpu 코어가 있고 여러 개의 i/o 컨트롤러들과 메모리들이 bus 에 몰려 있다. 이 버스를 AMBA(Arm Memory Bus Architecture) 라고 한다. 버스도 굉장히 중요한 로직 중 하나인데, 어느 장치를 선택하느냐, 어떤 데이터가 나가느냐 어떤 신호가 나가느냐를 정하는 논리 장치... cortex m3 는 AMBA. AMBA 에도 종류가 있는데, AHB(Arm High speed Bus) 가 있고, APB(Arm Periperal Bus) 가 있다. 메모리와 연결된 것들은AHB 와, APB는 메모리보다는 성능이 낫은 것들과...

## Instruction Set

우리는 지금까지 알아본 기본 지식을 바탕으로 마이크로 프로세서에 돌아갈 수 있는 프로그램을 작성할 것이다. 그것을 위해 cpu 내부 동작을 알아볼 것이다. 그를 위해 우리는 cortex m3 가 실행할 수 있는 명령어에 어떤 것들이 있는지를 대략적으로 알아보고, 다음 시간에 하나하나 자세히 배울 것. 

Instruction Set 이란 개념이 프로세서에서 가장 중요하고 필수적인 개념이다. Instruction Set (명령어 집합) 은 어떤 특정 cpu 가 실행할 수 있는 명령어들의 집합이다. 바꿔 말하자면, 어떤 프로세서를 설계할 때 이 프로세서가 실행할 수 있는 명령어들을 정의하고 그 명령어가 수행되도록 프로세서 하드웨어를 만든다. 우리는 이미 설계된 프로세서를 운영하는 입장으로, 이 프로세서를 어떻게 사용하는지를 배우는 입장이다.

어떤 프로그램이든 소스 코드가 명령어 집합으로 바뀌어 프로세서에서 돌아간다. 우리는 근본적인 것을 배울 것이다. 기본적으로 cortex m3는 ARM 계열의 프로세서이므로 ARM 명령어 set을 따른다. 따라서 우리는 32 bit ARM 명령어 set 를 알아야 한다.

명령어는 크게 세 가지 부류가 있다.

1. Arithmetic Logic (연산) - ADD, SUB
2. Data Move (데이터 이동) - MOV(레지스터간 데이터 이동)
3. Flow Control (소프트웨어의 흐름 제어) - STR(store)  주어진 순차적인 흐름대로 가다가 subroutine call 이나 interrupt 가 발생하면 jump 를 한다. 이렇게 흐름이 바뀌는데 이 흐름을 제어한다.

## ARM Instruction Set Architecture

mov 가 데이터 이동 명령어. ldr 는 데이터를 메모리에서 레지스터로 이동. sub 는 빼기. bne (ne 는 접미사로 낫 이콜. 조건문ㅇ르 만듬.) 에서 브랜치?는 프로그램의 흐름 제어.

이 명령어들이 CODE 영역이 들어가 있다. 4 개니까 16 byte 코드가 이 0000 0000 `~ 20000000 에 있다. 첫 번째 코드가 0x00000000 에 있다고 할 때 PC (R15) 가 00000000 을 가리키고 있다. PC 가 가리키는 코드를 mov r0, #4 해서 이 명령어를 실행시키기 위해 해석을 해서 cpu 가 실행하는 작업은 r0에 4 라는 값을 써넣는 것. 이 작업을 하면 이 cpu 는 명령어 하나를 실행시킨 것. 그 다음으로는 계속 그 다음 명령어를 수행한다. 이 때 기본적으로는 흐름 제어 명령어를 만나지 않는 이상 PC 값은 4 씩 증가하도록 되어 있다. 따라서 항상 순차적으로 프로그램이 실행되도록 설계되어 있다. 

ldr r1, [r0, #8] 명령어는 메모리의 값을 가져와 특정 레지스터에 넣으라는 명령어로, r1 위치에 r0 에 들어있는 값에 8 을 더한 값인 12 번지에 들어있는 값을 옮기라는 명령어이다.

bne loop 이란 명령어에서 loop 은 심볼인데 주소 값이 들어 있다. b 는 가치져서 다른 쪽으로 흐름을 바꿔서 이동하라는 명령어. ne 는 not equeal. 이 조건에 맞으면 loop 이라는 곳으로 jump 해서 흐름이 바뀐다. 

subs r2, #1 는 r2 에 들어있는 값에서 1을 빼서 다시 r2 에 넣으라는 명령어이다.

## Interrupt and Exception

이건 좀 더 디테일한 이야기인데 한 가지만 얘기하자면,

우리는 어떤 소프트웨어도 올라가있지 않은 cpu 를 운영시키려면 어떻게 해야하는지를 배우고 있다. cpu 는 어떻게 코드의 처음 시작 주소가 어디에 있는지 알고 실행하는지? 처음 cpu 에 파워를 넣어 실행시킬 때 (reset) 어디서부터 실행하도록 해야 하는지? reset을 포함해 cpu 가 받을 수 있는 interrupt 를 포함한 exception 의 번호, exception number를 정리. 여러가지 예외적인 상황이 발생했을 때에 대한 번호를 매기고 그 지정된 넘버에 따른 핸들링에 대한 테이블을 마련 (exception table) . reset 은 가장 우선순위가 높은 exception 이다. exception type 에는 그 외에도 다양하게 있다.

## Summary

정리를 하면, 이번 강의 시간에는 우리가 사용할 cortex m3 마이크로 프로세서에 대한 overview 와 그 지식을 바탕으로 cpu 가 어떻게 소프트웨어 프로그램, 즉 바이너리 프로그램, 명령어 프로그램을 실행시키는지를 간단하게 알아보았다.

Register, Memory Map, Interrupt Controller (NVIC), Instruction Set